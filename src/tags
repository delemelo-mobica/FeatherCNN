!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ActivationType	booster/include/booster/booster.h	/^enum ActivationType$/;"	g	namespace:booster
AddCreator	layer_factory.h	/^        static void AddCreator(const string &type, Creator creator)$/;"	f	class:feather::LayerRegistry
Alloc	blob.cpp	/^void Blob<Dtype>::Alloc()$/;"	f	class:feather::Blob
Alloc	mempool.cpp	/^bool CommonMemPool<PTR_TYPE>::Alloc()$/;"	f	class:CommonMemPool
Allocator	ncnn/allocator.h	/^class Allocator$/;"	c	namespace:ncnn
AssignCLPaddedDim	booster/include/booster/booster.h	/^    void AssignCLPaddedDim()$/;"	f	struct:booster::ConvParam
AssignOutputDim	booster/include/booster/booster.h	/^    void AssignOutputDim()$/;"	f	struct:booster::ConvParam
AssignPaddedDim	booster/include/booster/booster.h	/^    void AssignPaddedDim()$/;"	f	struct:booster::ConvParam
BORDER_CONSTANT	ncnn/mat.h	/^    BORDER_CONSTANT = 0,$/;"	e	enum:ncnn::__anon5
BORDER_REPLICATE	ncnn/mat.h	/^    BORDER_REPLICATE = 1,$/;"	e	enum:ncnn::__anon5
BatchNormLayer	layers/batchnorm_layer.h	/^        BatchNormLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::BatchNormLayer
BatchNormLayer	layers/batchnorm_layer.h	/^class BatchNormLayer : Layer$/;"	c	namespace:feather
Bias	booster/include/booster/winograd_kernels.h	/^    Nothing, Relu, Bias, BiasReLU$/;"	e	enum:WinogradOutType
BiasReLU	booster/include/booster/winograd_kernels.h	/^    Nothing, Relu, Bias, BiasReLU$/;"	e	enum:WinogradOutType
Blob	blob.h	/^        Blob()$/;"	f	class:feather::Blob
Blob	blob.h	/^        explicit Blob(Dtype* data, const size_t num, const size_t channels, const size_t height, const size_t width)$/;"	f	class:feather::Blob
Blob	blob.h	/^        explicit Blob(const size_t num, const size_t channels, const size_t height, const size_t width)$/;"	f	class:feather::Blob
Blob	blob.h	/^        explicit Blob(std::string name)$/;"	f	class:feather::Blob
Blob	blob.h	/^class Blob$/;"	c	namespace:feather
BuildBlobMap	net.cpp	/^int Net::BuildBlobMap()$/;"	f	class:feather::Net
CLBuffers	booster/include/booster/booster.h	/^struct CLBuffers$/;"	s	namespace:booster
CLOCK_MONOTONIC	booster/avx/helper.cpp	82;"	d	file:
COMPILE_WITH_FEATHERCNN	ncnn/platform.h	27;"	d
ChkParamHeader	utils.cpp	/^int ChkParamHeader(FILE* fp)$/;"	f
CommonMemPool	mempool.h	/^        CommonMemPool(): common_size(0), allocated_size(0), common_memory(NULL) {}$/;"	f	class:CommonMemPool
CommonMemPool	mempool.h	/^class CommonMemPool$/;"	c
ConcatLayer	layers/concat_layer.h	/^        ConcatLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::ConcatLayer
ConcatLayer	layers/concat_layer.h	/^class ConcatLayer : public Layer$/;"	c	namespace:feather
ConvAlgo	booster/include/booster/booster.h	/^enum ConvAlgo$/;"	g	namespace:booster
ConvBooster	booster/arm/booster.cpp	/^ConvBooster::ConvBooster()$/;"	f	class:booster::ConvBooster
ConvBooster	booster/avx/booster.cpp	/^ConvBooster::ConvBooster()$/;"	f	class:booster::ConvBooster
ConvBooster	booster/include/booster/booster.h	/^class ConvBooster$/;"	c	namespace:booster
ConvBoosterCL	booster/include/booster/booster.h	/^class ConvBoosterCL$/;"	c	namespace:booster
ConvLayer	layers/conv_layer.h	/^        ConvLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::ConvLayer
ConvLayer	layers/conv_layer.h	/^class ConvLayer : public Layer$/;"	c	namespace:feather
ConvParam	booster/include/booster/booster.h	/^struct ConvParam$/;"	s	namespace:booster
Copy	blob.h	/^        void Copy(const Blob<Dtype>* p_blob)$/;"	f	class:feather::Blob
CopyData	blob.h	/^        void CopyData(const Dtype* data)$/;"	f	class:feather::Blob
CopyDataFromMat	blob.cpp	/^int Blob<Dtype>::CopyDataFromMat(const ncnn::Mat& mat)$/;"	f	class:feather::Blob
CopyFromMat	blob.cpp	/^int Blob<Dtype>::CopyFromMat(const ncnn::Mat& mat)$/;"	f	class:feather::Blob
CopyShape	blob.h	/^        void CopyShape(const Blob<Dtype>* p_blob)$/;"	f	class:feather::Blob
CreateLayer	layer_factory.h	/^        static Layer *CreateLayer(std::string type, RuntimeParameter<float> *rt_param)$/;"	f	class:feather::LayerRegistry
Creator	layer_factory.h	/^        typedef Layer* (*Creator)(RuntimeParameter<float> *);$/;"	t	class:feather::LayerRegistry
CreatorRegistry	layer_factory.h	/^        typedef std::map<string, Creator> CreatorRegistry;$/;"	t	class:feather::LayerRegistry
DEFINE_LAYER_CREATOR	layer_factory.h	85;"	d
DEPTHWISE	booster/include/booster/booster.h	/^    DEPTHWISE,$/;"	e	enum:booster::ConvAlgo
DEPTHWISE_Forward	booster/arm/booster.cpp	/^int DEPTHWISE_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
DEPTHWISE_Forward	booster/avx/booster.cpp	/^int DEPTHWISE_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
DEPTHWISE_GetBufferSize	booster/arm/booster.cpp	/^int DEPTHWISE_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
DEPTHWISE_GetBufferSize	booster/avx/booster.cpp	/^int DEPTHWISE_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
DEPTHWISE_Init	booster/arm/booster.cpp	/^int DEPTHWISE_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
DEPTHWISE_Init	booster/avx/booster.cpp	/^int DEPTHWISE_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
DropoutLayer	layers/dropout_layer.h	/^        DropoutLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::DropoutLayer
DropoutLayer	layers/dropout_layer.h	/^class DropoutLayer : public Layer$/;"	c	namespace:feather
EltwiseLayer	layers/eltwise_layer.h	/^        EltwiseLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::EltwiseLayer
EltwiseLayer	layers/eltwise_layer.h	/^class EltwiseLayer : public Layer$/;"	c	namespace:feather
Extract	net.cpp	/^int Net::Extract(std::string blob_name, ncnn::Mat &out)$/;"	f	class:feather::Net
Extract	net.cpp	/^int Net::Extract(std::string name, float** output_ptr, int* n, int *c, int* h, int* w)$/;"	f	class:feather::Net
FEATHER_MEN_ALIGN	booster/include/booster/booster.h	34;"	d
FEATHER_MEN_ALIGN	booster/include/booster/booster.h	36;"	d
FORWARD_FUNC	booster/include/booster/booster.h	/^typedef int (*FORWARD_FUNC)(ConvParam *param, float* output, float* input, float* kernel, float* buffer, float* bias_arr);$/;"	t	namespace:booster
FORWARD_FUNC_CL	booster/include/booster/booster.h	/^        typedef int (*FORWARD_FUNC_CL)(cl::CommandQueue cmd_q,$/;"	t	class:booster::ConvBoosterCL
FeedInput	net.cpp	/^int Net::FeedInput(const char* input_name, ncnn::Mat& in)$/;"	f	class:feather::Net
FindBottomIDByName	layer.cpp	/^int Layer::FindBottomIDByName(std::string name)$/;"	f	class:feather::Layer
FindTopIDByName	layer.cpp	/^int Layer::FindTopIDByName(std::string name)$/;"	f	class:feather::Layer
ForceSelectAlgo	booster/arm/booster.cpp	/^int ConvBooster::ForceSelectAlgo(ConvAlgo algo)$/;"	f	class:booster::ConvBooster
ForceSelectAlgo	booster/avx/booster.cpp	/^int ConvBooster::ForceSelectAlgo(ConvAlgo algo)$/;"	f	class:booster::ConvBooster
Forward	booster/include/booster/booster.h	/^        FORWARD_FUNC Forward;$/;"	m	class:booster::ConvBooster
Forward	booster/include/booster/booster.h	/^        FORWARD_FUNC_CL Forward;$/;"	m	class:booster::ConvBoosterCL
Forward	layer.cpp	/^int Layer::Forward()$/;"	f	class:feather::Layer
Forward	layers/batchnorm_layer.h	/^        int Forward()$/;"	f	class:feather::BatchNormLayer
Forward	layers/concat_layer.h	/^        int Forward()$/;"	f	class:feather::ConcatLayer
Forward	layers/conv_layer.h	/^        int Forward()$/;"	f	class:feather::ConvLayer
Forward	layers/dropout_layer.h	/^        int Forward()$/;"	f	class:feather::DropoutLayer
Forward	layers/eltwise_layer.h	/^        int Forward()$/;"	f	class:feather::EltwiseLayer
Forward	layers/inner_product_layer.h	/^        int Forward()$/;"	f	class:feather::InnerProductLayer
Forward	layers/pooling_layer.h	/^        int Forward()$/;"	f	class:feather::PoolingLayer
Forward	layers/relu_layer.h	/^        int Forward()$/;"	f	class:feather::ReluLayer
Forward	layers/scale_layer.h	/^        int Forward()$/;"	f	class:feather::ScaleLayer
Forward	layers/softmax_layer.h	/^        int Forward()$/;"	f	class:feather::SoftmaxLayer
Forward	layers/split_layer.h	/^        int Forward()$/;"	f	class:feather::SplitLayer
Forward	net.cpp	/^int Net::Forward()$/;"	f	class:feather::Net
ForwardReshape	layer.cpp	/^int Layer::ForwardReshape()$/;"	f	class:feather::Layer
Free	blob.cpp	/^void Blob<Dtype>::Free()$/;"	f	class:feather::Blob
Free	mempool.cpp	/^bool CommonMemPool<PTR_TYPE>::Free()$/;"	f	class:CommonMemPool
Fuse	layer.cpp	/^int Layer::Fuse(Layer* next_layer)$/;"	f	class:feather::Layer
Fuse	layers/batchnorm_layer.h	/^        int Fuse(Layer *next_layer)$/;"	f	class:feather::BatchNormLayer
Fuse	layers/conv_layer.h	/^        int Fuse(Layer *next_layer)$/;"	f	class:feather::ConvLayer
Fuse	layers/inner_product_layer.h	/^        int Fuse(Layer *next_layer)$/;"	f	class:feather::InnerProductLayer
GEBPInnerKernel4x1x4	booster/arm/winograd_kernels.cpp	/^inline void GEBPInnerKernel4x1x4(float* &vp, float* UTp, float* WTp, const int beginIdx, const int endIdx, int inChannels, const int wstride)$/;"	f
GEBPInnerKernel4x2x4	booster/arm/winograd_kernels.cpp	/^inline void GEBPInnerKernel4x2x4(float* &vp, float* UTp, float* WTp, const int beginIdx, const int endIdx, int inChannels, const int wstride)$/;"	f
GEBPInnerKernel4x3x4	booster/arm/winograd_kernels.cpp	/^inline void GEBPInnerKernel4x3x4(float* &vp, float* UTp, float* WTp, const int beginIdx, const int endIdx, int inChannels, const int wstride)$/;"	f
GEBPInnerKernel4x4x4	booster/arm/winograd_kernels.cpp	/^inline void GEBPInnerKernel4x4x4(float* &vp, float* UTp, float* WTp, const int beginIdx, const int endIdx, int inChannels, const int wstride)$/;"	f
GEMMCubic	booster/arm/winograd_kernels.cpp	/^void GEMMCubic(float* output, int ldout, float* WT, float* VT, const int ldvt, float* UT, const int ldut, const int inChannels, const int outChannels, const int nRowBlocks, const int nColBlocks)$/;"	f
GEMMCubicFourOutputChannels	booster/arm/winograd_kernels.cpp	/^void GEMMCubicFourOutputChannels(float* output, int ldout, float* WT, float* VT, float* UT, const int inChannels, const int outChannels, const int nRowBlocks, const int nColBlocks, const int oc)$/;"	f
GET_BUFFER_SIZE_FUNC	booster/include/booster/booster.h	/^typedef int (*GET_BUFFER_SIZE_FUNC)(ConvParam *param, int* buffer_size, int* processed_kernel_size);$/;"	t	namespace:booster
GetBufferSize	booster/include/booster/booster.h	/^        GET_BUFFER_SIZE_FUNC GetBufferSize;$/;"	m	class:booster::ConvBooster
GetFLOPS	booster/include/booster/booster.h	/^    double GetFLOPS()$/;"	f	struct:booster::ConvParam
GetPtr	mempool.cpp	/^bool CommonMemPool<PTR_TYPE>::GetPtr(PTR_TYPE ** ptr)$/;"	f	class:CommonMemPool
HAVE_STRUCT_TIMESPEC	utils.h	22;"	d
IM2COL	booster/include/booster/booster.h	/^    IM2COL,$/;"	e	enum:booster::ConvAlgo
IM2COL_Forward	booster/arm/booster.cpp	/^int IM2COL_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
IM2COL_Forward	booster/avx/booster.cpp	/^int IM2COL_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
IM2COL_GetBufferSize	booster/arm/booster.cpp	/^int IM2COL_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
IM2COL_GetBufferSize	booster/avx/booster.cpp	/^int IM2COL_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
IM2COL_Init	booster/arm/booster.cpp	/^int IM2COL_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
IM2COL_Init	booster/avx/booster.cpp	/^int IM2COL_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
INIT_FUNC	booster/include/booster/booster.h	/^typedef int (*INIT_FUNC)(ConvParam *param, float* processed_kernel, float* kernel);$/;"	t	namespace:booster
INIT_FUNC_CL	booster/include/booster/booster.h	/^        typedef int (*INIT_FUNC_CL)(const std::vector<std::string>& program_names,$/;"	t	class:booster::ConvBoosterCL
Init	booster/include/booster/booster.h	/^        INIT_FUNC Init;$/;"	m	class:booster::ConvBooster
Init	booster/include/booster/booster.h	/^        INIT_FUNC_CL Init;$/;"	m	class:booster::ConvBoosterCL
Init	layer.cpp	/^int Layer::Init()$/;"	f	class:feather::Layer
Init	layers/batchnorm_layer.h	/^        int Init()$/;"	f	class:feather::BatchNormLayer
Init	layers/conv_layer.h	/^        int Init()$/;"	f	class:feather::ConvLayer
Init	layers/inner_product_layer.h	/^        int Init()$/;"	f	class:feather::InnerProductLayer
Init	layers/input_layer.h	/^        int Init()$/;"	f	class:feather::InputLayer
Init	layers/scale_layer.h	/^        int Init()$/;"	f	class:feather::ScaleLayer
InnerKernel	booster/arm/sgeconv.cpp	/^typedef void (*InnerKernel)(int K, float *packA, float *packB, float *c, int ldc);$/;"	t	namespace:booster	file:
InnerKernel	booster/arm/sgemm.cpp	/^typedef void (*InnerKernel)(int K, float *packA, float *packB, float *c, int ldc);$/;"	t	file:
InnerProductLayer	layers/inner_product_layer.h	/^        InnerProductLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::InnerProductLayer
InnerProductLayer	layers/inner_product_layer.h	/^class InnerProductLayer : public Layer$/;"	c	namespace:feather
InputLayer	layers/input_layer.h	/^        InputLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::InputLayer
InputLayer	layers/input_layer.h	/^class InputLayer : public Layer $/;"	c	namespace:feather
LAYER_TIMING	net.cpp	25;"	d	file:
LOGD	booster/include/booster/helper.h	26;"	d
LOGD	utils.h	34;"	d
LOGE	booster/include/booster/helper.h	27;"	d
LOGE	utils.h	35;"	d
LOGI	booster/include/booster/helper.h	25;"	d
LOGI	utils.h	33;"	d
Layer	layer.cpp	/^Layer::Layer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::Layer
Layer	layer.h	/^class Layer$/;"	c	namespace:feather
LayerRegisterer	layer_factory.h	/^        LayerRegisterer(const string &type,$/;"	f	class:feather::LayerRegisterer
LayerRegisterer	layer_factory.h	/^class LayerRegisterer$/;"	c	namespace:feather
LayerRegistry	layer_factory.h	/^        LayerRegistry() {}$/;"	f	class:feather::LayerRegistry
LayerRegistry	layer_factory.h	/^class LayerRegistry$/;"	c	namespace:feather
LoadParam	layer.cpp	/^int Layer::LoadParam(const ncnn::ParamDict& pd)$/;"	f	class:feather::Layer
LoadParam	layers/batchnorm_layer.h	/^        int LoadParam(const ncnn::ParamDict &pd)$/;"	f	class:feather::BatchNormLayer
LoadParam	layers/concat_layer.h	/^        int LoadParam(const ncnn::ParamDict& pd)$/;"	f	class:feather::ConcatLayer
LoadParam	layers/conv_layer.h	/^        int LoadParam(const ncnn::ParamDict& pd)$/;"	f	class:feather::ConvLayer
LoadParam	layers/dropout_layer.h	/^        int LoadParam(const ncnn::ParamDict &pd)$/;"	f	class:feather::DropoutLayer
LoadParam	layers/eltwise_layer.h	/^        int LoadParam(const ncnn::ParamDict &pd)$/;"	f	class:feather::EltwiseLayer
LoadParam	layers/inner_product_layer.h	/^        int LoadParam(const ncnn::ParamDict &pd)$/;"	f	class:feather::InnerProductLayer
LoadParam	layers/input_layer.h	/^        int LoadParam(const ncnn::ParamDict& pd)$/;"	f	class:feather::InputLayer
LoadParam	layers/pooling_layer.h	/^        int LoadParam(const ncnn::ParamDict& pd)$/;"	f	class:feather::PoolingLayer
LoadParam	layers/scale_layer.h	/^        int LoadParam(const ncnn::ParamDict &pd)$/;"	f	class:feather::ScaleLayer
LoadParam	net.cpp	/^int Net::LoadParam(FILE* param_fp)$/;"	f	class:feather::Net
LoadParam	net.cpp	/^int Net::LoadParam(const char* path)$/;"	f	class:feather::Net
LoadWeights	layer.cpp	/^int Layer::LoadWeights(const ncnn::ModelBin& mb)$/;"	f	class:feather::Layer
LoadWeights	layers/batchnorm_layer.h	/^        int LoadWeights(const ncnn::ModelBin &mb)$/;"	f	class:feather::BatchNormLayer
LoadWeights	layers/conv_layer.h	/^        int LoadWeights(const ncnn::ModelBin& mb)$/;"	f	class:feather::ConvLayer
LoadWeights	layers/inner_product_layer.h	/^        int LoadWeights(const ncnn::ModelBin& mb)$/;"	f	class:feather::InnerProductLayer
LoadWeights	layers/scale_layer.h	/^        int LoadWeights(const ncnn::ModelBin &mb)$/;"	f	class:feather::ScaleLayer
LoadWeights	net.cpp	/^int Net::LoadWeights(FILE* fp)$/;"	f	class:feather::Net
LoadWeights	net.cpp	/^int Net::LoadWeights(const char* path)$/;"	f	class:feather::Net
LogParams	booster/include/booster/booster.h	/^    void LogParams(const char* layer_name)$/;"	f	struct:booster::ConvParam
MALLOC_ALIGN	ncnn/allocator.h	38;"	d
MAX	layers/pooling_layer.h	22;"	d
MEMPOOL_CHECK_RETURN	mempool.h	19;"	d
MIN	layers/pooling_layer.h	23;"	d
MM256_ARRAY_UNION	booster/avx/winograd_kernels_F63_fused.cpp	/^union MM256_ARRAY_UNION$/;"	u	namespace:Winograd_F63_Fused	file:
Mat	ncnn/mat.h	/^class Mat$/;"	c	namespace:ncnn
Mat	ncnn/mat.h	/^inline Mat::Mat()$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(const Mat& m)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, int _c, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, int _c, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, int _c, void* _data, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, int _c, void* _data, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, void* _data, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, int _h, void* _data, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, void* _data, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
Mat	ncnn/mat.h	/^inline Mat::Mat(int _w, void* _data, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
ModelBin	ncnn/modelbin.h	/^class ModelBin$/;"	c	namespace:ncnn
ModelBinFromMatArray	ncnn/modelbin.cpp	/^ModelBinFromMatArray::ModelBinFromMatArray(const Mat* _weights) : weights(_weights)$/;"	f	class:ncnn::ModelBinFromMatArray
ModelBinFromMatArray	ncnn/modelbin.h	/^class ModelBinFromMatArray : public ModelBin$/;"	c	namespace:ncnn
ModelBinFromMemory	ncnn/modelbin.cpp	/^ModelBinFromMemory::ModelBinFromMemory(const unsigned char*& _mem) : mem(_mem)$/;"	f	class:ncnn::ModelBinFromMemory
ModelBinFromMemory	ncnn/modelbin.h	/^class ModelBinFromMemory : public ModelBin$/;"	c	namespace:ncnn
ModelBinFromStdio	ncnn/modelbin.cpp	/^ModelBinFromStdio::ModelBinFromStdio(FILE* _binfp) : binfp(_binfp)$/;"	f	class:ncnn::ModelBinFromStdio
ModelBinFromStdio	ncnn/modelbin.h	/^class ModelBinFromStdio : public ModelBin$/;"	c	namespace:ncnn
Mutex	ncnn/allocator.h	/^    Mutex() { InitializeSRWLock(&srwlock); }$/;"	f	class:ncnn::Mutex
Mutex	ncnn/allocator.h	/^    Mutex() { pthread_mutex_init(&mutex, 0); }$/;"	f	class:ncnn::Mutex
Mutex	ncnn/allocator.h	/^class Mutex$/;"	c	namespace:ncnn
MutexLockGuard	ncnn/allocator.h	/^    MutexLockGuard(Mutex& _mutex) : mutex(_mutex) { mutex.lock(); }$/;"	f	class:ncnn::MutexLockGuard
MutexLockGuard	ncnn/allocator.h	/^class MutexLockGuard$/;"	c	namespace:ncnn
NAIVE	booster/include/booster/booster.h	/^    NAIVE,$/;"	e	enum:booster::ConvAlgo
NAIVE_Forward	booster/arm/booster.cpp	/^int NAIVE_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
NAIVE_Forward	booster/avx/booster.cpp	/^int NAIVE_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
NAIVE_GetBufferSize	booster/arm/booster.cpp	/^int NAIVE_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
NAIVE_GetBufferSize	booster/avx/booster.cpp	/^int NAIVE_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
NAIVE_Init	booster/arm/booster.cpp	/^int NAIVE_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
NAIVE_Init	booster/avx/booster.cpp	/^int NAIVE_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
NCNN_ALLOCATOR_H	ncnn/allocator.h	16;"	d
NCNN_BENCHMARK	ncnn/platform.h	21;"	d
NCNN_IM2COL_SGEMM	ncnn/platform.h	26;"	d
NCNN_MAT_H	ncnn/mat.h	16;"	d
NCNN_MAX_PARAM_COUNT	ncnn/paramdict.h	23;"	d
NCNN_MODELBIN_H	ncnn/modelbin.h	16;"	d
NCNN_OPENCV	ncnn/platform.h	20;"	d
NCNN_PARAMDICT_H	ncnn/paramdict.h	16;"	d
NCNN_PIXEL	ncnn/platform.h	22;"	d
NCNN_PIXEL_ROTATE	ncnn/platform.h	23;"	d
NCNN_PLATFORM_H	ncnn/platform.h	16;"	d
NCNN_REQUANT	ncnn/platform.h	25;"	d
NCNN_STDIO	ncnn/platform.h	18;"	d
NCNN_STRING	ncnn/platform.h	19;"	d
NCNN_VULKAN	ncnn/platform.h	24;"	d
NCNN_XADD	ncnn/allocator.h	/^static inline int NCNN_XADD(int* addr, int delta) { int tmp = *addr; *addr += delta; return tmp; }$/;"	f	namespace:ncnn
NCNN_XADD	ncnn/allocator.h	102;"	d
NCNN_XADD	ncnn/allocator.h	104;"	d
NCNN_XADD	ncnn/allocator.h	109;"	d
NCNN_XADD	ncnn/allocator.h	111;"	d
NCNN_XADD	ncnn/allocator.h	116;"	d
NCNN_XADD	ncnn/allocator.h	98;"	d
Net	net.cpp	/^Net::Net() :$/;"	f	class:feather::Net
Net	net.h	/^class Net$/;"	c	namespace:feather
None	booster/include/booster/booster.h	/^    None,$/;"	e	enum:booster::ActivationType
Nothing	booster/include/booster/winograd_kernels.h	/^    Nothing, Relu, Bias, BiasReLU$/;"	e	enum:WinogradOutType
Operation_MAX	layers/eltwise_layer.h	/^        enum { Operation_PROD = 0, Operation_SUM = 1, Operation_MAX = 2 };$/;"	e	enum:feather::EltwiseLayer::__anon1
Operation_PROD	layers/eltwise_layer.h	/^        enum { Operation_PROD = 0, Operation_SUM = 1, Operation_MAX = 2 };$/;"	e	enum:feather::EltwiseLayer::__anon1
Operation_SUM	layers/eltwise_layer.h	/^        enum { Operation_PROD = 0, Operation_SUM = 1, Operation_MAX = 2 };$/;"	e	enum:feather::EltwiseLayer::__anon1
PIXEL_BGR	ncnn/mat.h	/^        PIXEL_BGR       = (1 << 1),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_BGR2GRAY	ncnn/mat.h	/^        PIXEL_BGR2GRAY  = PIXEL_BGR | (PIXEL_GRAY << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_BGR2RGB	ncnn/mat.h	/^        PIXEL_BGR2RGB   = PIXEL_BGR | (PIXEL_RGB << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_CONVERT_MASK	ncnn/mat.h	/^        PIXEL_CONVERT_MASK = 0xffff0000,$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_CONVERT_SHIFT	ncnn/mat.h	/^        PIXEL_CONVERT_SHIFT = 16,$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_FORMAT_MASK	ncnn/mat.h	/^        PIXEL_FORMAT_MASK = 0x0000ffff,$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_GRAY	ncnn/mat.h	/^        PIXEL_GRAY      = (1 << 2),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_GRAY2BGR	ncnn/mat.h	/^        PIXEL_GRAY2BGR  = PIXEL_GRAY | (PIXEL_BGR << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_GRAY2RGB	ncnn/mat.h	/^        PIXEL_GRAY2RGB  = PIXEL_GRAY | (PIXEL_RGB << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGB	ncnn/mat.h	/^        PIXEL_RGB       = 1,$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGB2BGR	ncnn/mat.h	/^        PIXEL_RGB2BGR   = PIXEL_RGB | (PIXEL_BGR << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGB2GRAY	ncnn/mat.h	/^        PIXEL_RGB2GRAY  = PIXEL_RGB | (PIXEL_GRAY << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGBA	ncnn/mat.h	/^        PIXEL_RGBA      = (1 << 3),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGBA2BGR	ncnn/mat.h	/^        PIXEL_RGBA2BGR  = PIXEL_RGBA | (PIXEL_BGR << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGBA2GRAY	ncnn/mat.h	/^        PIXEL_RGBA2GRAY = PIXEL_RGBA | (PIXEL_GRAY << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PIXEL_RGBA2RGB	ncnn/mat.h	/^        PIXEL_RGBA2RGB  = PIXEL_RGBA | (PIXEL_RGB << PIXEL_CONVERT_SHIFT),$/;"	e	enum:ncnn::Mat::__anon4
PRINT_SETUP_LOG	net.cpp	26;"	d	file:
PackAFunc	booster/arm/sgemm_legacy.cpp	/^typedef void (*PackAFunc)(int L, float* packA, float* a, int lda);$/;"	t	file:
ParamDict	ncnn/paramdict.cpp	/^ParamDict::ParamDict()$/;"	f	class:ncnn::ParamDict
ParamDict	ncnn/paramdict.h	/^class ParamDict$/;"	c	namespace:ncnn
PoolAllocator	ncnn/allocator.cpp	/^PoolAllocator::PoolAllocator()$/;"	f	class:ncnn::PoolAllocator
PoolAllocator	ncnn/allocator.h	/^class PoolAllocator : public Allocator$/;"	c	namespace:ncnn
PoolingLayer	layers/pooling_layer.h	/^        PoolingLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::PoolingLayer
PoolingLayer	layers/pooling_layer.h	/^class PoolingLayer : public Layer$/;"	c	namespace:feather
PrintBlobInfo	blob.h	/^        void PrintBlobInfo() const$/;"	f	class:feather::Blob
REGISTER_LAYER_CREATOR	layer_factory.h	89;"	d
ReLU	booster/include/booster/booster.h	/^    ReLU,$/;"	e	enum:booster::ActivationType
Realloc	blob.cpp	/^void Blob<Dtype>::Realloc(size_t elem_size)$/;"	f	class:feather::Blob
Registry	layer_factory.h	/^        static CreatorRegistry &Registry()$/;"	f	class:feather::LayerRegistry
RelaceString	utils.cpp	/^void StringTool::RelaceString(std::string &input, const std::string &delim, const std::string& repstr)$/;"	f	class:StringTool
Relu	booster/include/booster/winograd_kernels.h	/^    Nothing, Relu, Bias, BiasReLU$/;"	e	enum:WinogradOutType
ReluLayer	layers/relu_layer.h	/^        ReluLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::ReluLayer
ReluLayer	layers/relu_layer.h	/^class ReluLayer : public Layer$/;"	c	namespace:feather
Request	mempool.cpp	/^bool CommonMemPool<PTR_TYPE>::Request(size_t size_byte)$/;"	f	class:CommonMemPool
Reset	mempool.cpp	/^bool CommonMemPool<PTR_TYPE>::Reset()$/;"	f	class:CommonMemPool
Reshape	layer.cpp	/^int Layer::Reshape()$/;"	f	class:feather::Layer
Reshape	layers/concat_layer.h	/^        int Reshape()$/;"	f	class:feather::ConcatLayer
Reshape	layers/conv_layer.h	/^        int Reshape()$/;"	f	class:feather::ConvLayer
Reshape	layers/eltwise_layer.h	/^        int Reshape()$/;"	f	class:feather::EltwiseLayer
Reshape	layers/inner_product_layer.h	/^        int Reshape()$/;"	f	class:feather::InnerProductLayer
Reshape	layers/input_layer.h	/^        int Reshape()$/;"	f	class:feather::InputLayer
Reshape	layers/pooling_layer.h	/^        int Reshape()$/;"	f	class:feather::PoolingLayer
Reshape	layers/split_layer.h	/^        int Reshape()$/;"	f	class:feather::SplitLayer
Reshape	net.cpp	/^int Net::Reshape()$/;"	f	class:feather::Net
ReshapeWithRealloc	blob.cpp	/^void Blob<Dtype>::ReshapeWithRealloc(const Blob<Dtype> *p_blob)$/;"	f	class:feather::Blob
ReshapeWithRealloc	blob.cpp	/^void Blob<Dtype>::ReshapeWithRealloc(int num, int channels, int height, int width)$/;"	f	class:feather::Blob
RuntimeParameter	rt_param.h	/^        RuntimeParameter() : _common_mempool(NULL),$/;"	f	class:RuntimeParameter
RuntimeParameter	rt_param.h	/^        RuntimeParameter(CommonMemPool<Dtype> *common_mempool, size_t num_threads)$/;"	f	class:RuntimeParameter
RuntimeParameter	rt_param.h	/^class RuntimeParameter$/;"	c
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	103;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	304;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	358;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	49;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	597;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	651;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	895;"	d	file:
SATURATE_CAST_SHORT	ncnn/mat_pixel_resize.cpp	949;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	1266;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	1322;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	139;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	155;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	245;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	257;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	390;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	408;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	523;"	d	file:
SATURATE_CAST_UCHAR	ncnn/mat_pixel.cpp	539;"	d	file:
SET_BUILD_OPTS_CL	booster/include/booster/booster.h	/^        typedef int (*SET_BUILD_OPTS_CL)(const ConvParam& param,$/;"	t	class:booster::ConvBoosterCL
SET_CONV_KERNEL_PARAMS_CL	booster/include/booster/booster.h	/^        typedef int (*SET_CONV_KERNEL_PARAMS_CL)(const ConvParam& param,$/;"	t	class:booster::ConvBoosterCL
SET_CONV_WORK_SIZE_CL	booster/include/booster/booster.h	/^        typedef int (*SET_CONV_WORK_SIZE_CL)(const ConvParam& param,$/;"	t	class:booster::ConvBoosterCL
SGEBP_externalPackA_tiny_scale	booster/arm/sgemm_legacy.cpp	/^void SGEBP_externalPackA_tiny_scale(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc, float* packA, float* packB, SGEMMInnerKernel sgemm_tiny_scale)$/;"	f
SGEBP_externalPackA_tiny_scale_8x8	booster/arm/sgemm_legacy.cpp	/^void SGEBP_externalPackA_tiny_scale_8x8(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc, float* packA, float* packB, SGEMMInnerKernel sgemm_tiny_scale)$/;"	f
SGEBP_internalPack_tiny_scale	booster/arm/sgemm_legacy.cpp	/^void SGEBP_internalPack_tiny_scale(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc, float* packA, float* packB, PackAFunc internalPackA, SGEMMInnerKernel sgemm_tiny_scale)$/;"	f
SGEBP_internal_pack	booster/arm/sgemm_legacy.cpp	/^void SGEBP_internal_pack(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc, float* packA, float* packB)$/;"	f
SGECONV	booster/include/booster/booster.h	/^    SGECONV,$/;"	e	enum:booster::ConvAlgo
SGECONV_Forward	booster/arm/booster.cpp	/^int SGECONV_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
SGECONV_Forward	booster/avx/booster.cpp	/^int SGECONV_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
SGECONV_GetBufferSize	booster/arm/booster.cpp	/^int SGECONV_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
SGECONV_GetBufferSize	booster/avx/booster.cpp	/^int SGECONV_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
SGECONV_Init	booster/arm/booster.cpp	/^int SGECONV_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
SGECONV_Init	booster/avx/booster.cpp	/^int SGECONV_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
SGEMMInnerKernel	booster/arm/sgemm_legacy.cpp	/^typedef void (*SGEMMInnerKernel)(int L, float *a, int lda, float *b, int ldb, float *c, int ldc);$/;"	t	file:
ScaleLayer	layers/scale_layer.h	/^        ScaleLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::ScaleLayer
ScaleLayer	layers/scale_layer.h	/^class ScaleLayer : public Layer$/;"	c	namespace:feather
SelectAlgo	booster/arm/booster.cpp	/^int ConvBooster::SelectAlgo(ConvParam* param)$/;"	f	class:booster::ConvBooster
SelectAlgo	booster/avx/booster.cpp	/^int ConvBooster::SelectAlgo(ConvParam* param)$/;"	f	class:booster::ConvBooster
SetBuildOpts	booster/include/booster/booster.h	/^        SET_BUILD_OPTS_CL SetBuildOpts;$/;"	m	class:booster::ConvBoosterCL
SetConvKernelParams	booster/include/booster/booster.h	/^        SET_CONV_KERNEL_PARAMS_CL SetConvKernelParams;$/;"	m	class:booster::ConvBoosterCL
SetConvWorkSize	booster/include/booster/booster.h	/^        SET_CONV_WORK_SIZE_CL SetConvWorkSize;$/;"	m	class:booster::ConvBoosterCL
SetFuncs	booster/arm/booster.cpp	/^int ConvBooster::SetFuncs()$/;"	f	class:booster::ConvBooster
SetFuncs	booster/avx/booster.cpp	/^int ConvBooster::SetFuncs()$/;"	f	class:booster::ConvBooster
SetKernel	layers/batchnorm_layer.h	/^        int SetKernel()$/;"	f	class:feather::BatchNormLayer
SoftmaxLayer	layers/softmax_layer.h	/^        SoftmaxLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::SoftmaxLayer
SoftmaxLayer	layers/softmax_layer.h	/^class SoftmaxLayer : public Layer$/;"	c	namespace:feather
SplitLayer	layers/split_layer.h	/^        SplitLayer(RuntimeParameter<float>* rt_param)$/;"	f	class:feather::SplitLayer
SplitLayer	layers/split_layer.h	/^class SplitLayer : public Layer$/;"	c	namespace:feather
SplitString	utils.cpp	/^void StringTool::SplitString(const std::string &input, const std::string &delim, std::vector<std::string> &parts)$/;"	f	class:StringTool
StringTool	utils.h	/^class StringTool$/;"	c
TCNN_SGEMM_H_	booster/arm/sgemm_legacy.h	16;"	d
TensorGEMM	booster/arm/winograd_kernels_F63.cpp	/^void TensorGEMM(float *WT, const float *VT, const float *UT, const int depth, const int inChannels, const int outChannels, const int nRowBlocks, const int nColBlocks, const int num_threads, float* pack_arr, const int cache_block)$/;"	f
TensorGEMM	booster/avx/winograd_kernels_F63.cpp	/^void TensorGEMM(float *WT, const float *VT, const float *UT, const int depth, const int inChannels, const int outChannels, const int nRowBlocks, const int nColBlocks, const int num_threads, float* pack_arr, const int cache_block)$/;"	f
TensorGEMMInnerKernel4x1x4	booster/arm/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x1x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x1x4	booster/avx/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x1x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x2x4	booster/arm/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x2x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x2x4	booster/avx/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x2x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x3x4	booster/arm/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x3x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x3x4	booster/avx/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x3x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x4x4	booster/arm/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x4x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x4x4	booster/avx/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x4x4(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x4x4_avx	booster/avx/winograd_kernels_F63.cpp	/^static inline void TensorGEMMInnerKernel4x4x4_avx(float* &WTp, const int &wstride, const float* &UTp, const float* &vp, const int &inChannels)$/;"	f	file:
TensorGEMMInnerKernel4x4x4_avx	booster/avx/winograd_kernels_F63_fused.cpp	/^static inline void TensorGEMMInnerKernel4x4x4_avx(float *&WTp, const float *&UTp, const float *&vp, const int &inChannels, bool set_zero)$/;"	f	namespace:Winograd_F63_Fused
ThreadPool	booster/include/booster/thpool.h	/^class ThreadPool {$/;"	c
ThreadPool	booster/include/booster/thpool.h	/^inline ThreadPool::ThreadPool(size_t threads)$/;"	f	class:ThreadPool
Timer	booster/include/booster/helper.h	/^        Timer() {}$/;"	f	class:Timer
Timer	booster/include/booster/helper.h	/^class Timer$/;"	c
TryFuse	layer.cpp	/^int Layer::TryFuse(Layer *next_layer)$/;"	f	class:feather::Layer
UnlockedPoolAllocator	ncnn/allocator.cpp	/^UnlockedPoolAllocator::UnlockedPoolAllocator()$/;"	f	class:ncnn::UnlockedPoolAllocator
UnlockedPoolAllocator	ncnn/allocator.h	/^class UnlockedPoolAllocator : public Allocator$/;"	c	namespace:ncnn
VkAllocator	ncnn/allocator.h	/^class VkAllocator$/;"	c	namespace:ncnn
VkBlobBufferAllocator	ncnn/allocator.h	/^class VkBlobBufferAllocator : public VkUnlockedBlobBufferAllocator$/;"	c	namespace:ncnn
VkBufferMemory	ncnn/allocator.h	/^class VkBufferMemory$/;"	c	namespace:ncnn
VkStagingBufferAllocator	ncnn/allocator.h	/^class VkStagingBufferAllocator : public VkUnlockedStagingBufferAllocator$/;"	c	namespace:ncnn
VkUnlockedBlobBufferAllocator	ncnn/allocator.h	/^class VkUnlockedBlobBufferAllocator : public VkAllocator$/;"	c	namespace:ncnn
VkUnlockedStagingBufferAllocator	ncnn/allocator.h	/^class VkUnlockedStagingBufferAllocator : public VkAllocator$/;"	c	namespace:ncnn
VkWeightBufferAllocator	ncnn/allocator.h	/^class VkWeightBufferAllocator : public VkAllocator$/;"	c	namespace:ncnn
VkWeightStagingBufferAllocator	ncnn/allocator.h	/^class VkWeightStagingBufferAllocator : public VkAllocator$/;"	c	namespace:ncnn
WEIGHT_REFORM_FUNC_CL	booster/include/booster/booster.h	/^        typedef int (*WEIGHT_REFORM_FUNC_CL)(const ConvParam& param,$/;"	t	class:booster::ConvBoosterCL
WIN32_LEAN_AND_MEAN	ncnn/allocator.h	19;"	d
WINOGRADF23	booster/include/booster/booster.h	/^    WINOGRADF23,$/;"	e	enum:booster::ConvAlgo
WINOGRADF23_Forward	booster/arm/booster.cpp	/^int WINOGRADF23_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
WINOGRADF23_Forward	booster/avx/booster.cpp	/^int WINOGRADF23_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
WINOGRADF23_GetBufferSize	booster/arm/booster.cpp	/^int WINOGRADF23_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
WINOGRADF23_GetBufferSize	booster/avx/booster.cpp	/^int WINOGRADF23_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
WINOGRADF23_Init	booster/arm/booster.cpp	/^int WINOGRADF23_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
WINOGRADF23_Init	booster/avx/booster.cpp	/^int WINOGRADF23_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
WINOGRADF63	booster/include/booster/booster.h	/^    WINOGRADF63,$/;"	e	enum:booster::ConvAlgo
WINOGRADF63FUSED	booster/include/booster/booster.h	/^    WINOGRADF63FUSED,$/;"	e	enum:booster::ConvAlgo
WINOGRADF63FUSED_Forward	booster/avx/booster.cpp	/^int WINOGRADF63FUSED_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
WINOGRADF63FUSED_GetBufferSize	booster/avx/booster.cpp	/^int WINOGRADF63FUSED_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
WINOGRADF63FUSED_Init	booster/avx/booster.cpp	/^int WINOGRADF63FUSED_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
WINOGRADF63_Forward	booster/arm/booster.cpp	/^int WINOGRADF63_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
WINOGRADF63_Forward	booster/avx/booster.cpp	/^int WINOGRADF63_Forward(ConvParam *param, float* output, float* input, float* processed_kernel, float* buffer, float* bias_arr)$/;"	f	namespace:booster
WINOGRADF63_GetBufferSize	booster/arm/booster.cpp	/^int WINOGRADF63_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
WINOGRADF63_GetBufferSize	booster/avx/booster.cpp	/^int WINOGRADF63_GetBufferSize(ConvParam *param, int* buffer_size, int* processed_kernel_size)$/;"	f	namespace:booster
WINOGRADF63_Init	booster/arm/booster.cpp	/^int WINOGRADF63_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
WINOGRADF63_Init	booster/avx/booster.cpp	/^int WINOGRADF63_Init(ConvParam *param, float* processed_kernel, float* kernel)$/;"	f	namespace:booster
WeightReform	booster/include/booster/booster.h	/^        WEIGHT_REFORM_FUNC_CL WeightReform;$/;"	m	class:booster::ConvBoosterCL
WinogradF63Fused	booster/avx/winograd_kernels_F63_fused.cpp	/^void WinogradF63Fused(booster::ConvParam* conv_param, float* output, const float* input, const float* transformed_weights, const float* bias_arr, float* buffers, ThreadPool* thpool)$/;"	f	namespace:Winograd_F63_Fused
WinogradOutType	booster/include/booster/winograd_kernels.h	/^enum WinogradOutType$/;"	g
WinogradOutputTransformBlockAVX	booster/avx/winograd_kernels_F63_fused.cpp	/^void WinogradOutputTransformBlockAVX(const float *WT, float *output, const int ldout, const int ldchannel, const int vx, const int vy, const int block_stride, const float bias)$/;"	f	namespace:Winograd_F63_Fused
Winograd_F63_Fused	booster/avx/winograd_kernels_F63_fused.cpp	/^namespace Winograd_F63_Fused$/;"	n	file:
Winograd_F63_Fused	booster/include/booster/winograd_kernels.h	/^namespace Winograd_F63_Fused$/;"	n
_channels	blob.h	/^        size_t _channels;$/;"	m	class:feather::Blob
_common_mempool	rt_param.h	/^        CommonMemPool<Dtype> *_common_mempool;$/;"	m	class:RuntimeParameter
_data	blob.h	/^        void* _data;$/;"	m	class:feather::Blob
_elemsize	blob.h	/^        size_t _elemsize;$/;"	m	class:feather::Blob
_fusible	layer.h	/^        bool _fusible;$/;"	m	class:feather::Layer
_height	blob.h	/^        size_t _height;$/;"	m	class:feather::Blob
_inplace	layer.h	/^        bool _inplace;$/;"	m	class:feather::Layer
_mm256_loadu2_m128	booster/avx/winograd_kernels_F63_fused.cpp	40;"	d	file:
_mm256_set_m128	booster/avx/winograd_kernels_F63_fused.cpp	38;"	d	file:
_mm_free	utils.cpp	/^void _mm_free(void* ptr)$/;"	f
_mm_malloc	utils.cpp	/^void* _mm_malloc(size_t sz, size_t align)$/;"	f
_net_initialized	net.h	/^        int _net_initialized;$/;"	m	class:feather::Net
_num	blob.h	/^        size_t _num;$/;"	m	class:feather::Blob
_num_threads	rt_param.h	/^        size_t _num_threads;$/;"	m	class:RuntimeParameter
_param_loaded	net.h	/^        int _param_loaded;$/;"	m	class:feather::Net
_weights_loaded	net.h	/^        int _weights_loaded;$/;"	m	class:feather::Net
_width	blob.h	/^        size_t _width;$/;"	m	class:feather::Blob
activate	booster/arm/sgeconv.cpp	/^inline void activate(int rows, float* C, int ldc, float* bias)$/;"	f	namespace:booster
activation	booster/include/booster/booster.h	/^    ActivationType activation;$/;"	m	struct:booster::ConvParam
add	booster/arm/generic_kernels.cpp	/^void add(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
add	booster/avx/generic_kernels.cpp	/^void add(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
add_coeff	booster/arm/generic_kernels.cpp	/^void add_coeff(float* dst, float* A, float* coffA, float* B, float* coffB, size_t len, size_t num_threads)$/;"	f	namespace:booster
add_coeff	booster/avx/generic_kernels.cpp	/^void add_coeff(float* dst, float* A, float* coffA, float* B, float* coffB, size_t len, size_t num_threads)$/;"	f	namespace:booster
add_relu	booster/arm/generic_kernels.cpp	/^void add_relu(float* dst, const float* A, const float* B, const size_t len, const size_t num_threads)$/;"	f	namespace:booster
add_relu	booster/avx/generic_kernels.cpp	/^void add_relu(float* dst, const float* A, const float* B, const size_t len, const size_t num_threads)$/;"	f	namespace:booster
addref	ncnn/mat.h	/^inline void Mat::addref()$/;"	f	class:ncnn::Mat
algo	booster/include/booster/booster.h	/^        ConvAlgo algo;$/;"	m	class:booster::ConvBooster
algo	booster/include/booster/booster.h	/^        ConvAlgo algo;$/;"	m	class:booster::ConvBoosterCL
alignPtr	ncnn/allocator.h	/^template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))$/;"	f	namespace:ncnn
alignSize	ncnn/allocator.h	/^static inline size_t alignSize(size_t sz, int n)$/;"	f	namespace:ncnn
align_ceil	booster/arm/sgeconv.cpp	/^int align_ceil(int num, int align)$/;"	f	namespace:booster
align_ceil	booster/arm/sgemm.cpp	/^int align_ceil(int num, int align)$/;"	f
align_ceil	booster/avx/sgeconv.cpp	/^int align_ceil(int num, int align)$/;"	f
align_ceil	booster/avx/sgemm.cpp	/^int align_ceil(int num, int align)$/;"	f
allocated_size	mempool.h	/^        size_t allocated_size;$/;"	m	class:CommonMemPool
allocator	ncnn/mat.h	/^    Allocator* allocator;$/;"	m	class:ncnn::Mat
arr	booster/avx/winograd_kernels_F63_fused.cpp	/^    int arr[8];$/;"	m	union:Winograd_F63_Fused::MM256_ARRAY_UNION	file:
axis	layers/concat_layer.h	/^        int axis;$/;"	m	class:feather::ConcatLayer
batchnorm	booster/arm/generic_kernels.cpp	/^void batchnorm(const size_t channels, const size_t stride, const float* alpha, const float* beta, const float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads)$/;"	f	namespace:booster
batchnorm	booster/avx/generic_kernels.cpp	/^void batchnorm(const size_t channels, const size_t stride, const float* alpha, const float* beta, const float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads)$/;"	f	namespace:booster
biasRelu	booster/arm/generic_kernels.cpp	/^void biasRelu(float* arr, int len, float bias)$/;"	f	namespace:booster
biasRelu	booster/avx/generic_kernels.cpp	/^void biasRelu(float* arr, int len, float bias)$/;"	f	namespace:booster
biasReluVec	booster/arm/generic_kernels.cpp	/^void biasReluVec(float* arr, int len, float bias)$/;"	f	namespace:booster
biasReluVec	booster/avx/generic_kernels.cpp	/^void biasReluVec(float* arr, int len, float bias)$/;"	f	namespace:booster
biasReluVecOpenmp	booster/arm/generic_kernels.cpp	/^void biasReluVecOpenmp(float* arr, int len, float bias, int nThreads)$/;"	f	namespace:booster
biasReluVecOpenmp	booster/avx/generic_kernels.cpp	/^void biasReluVecOpenmp(float* arr, int len, float bias, int nThreads)$/;"	f	namespace:booster
biasVec	booster/arm/generic_kernels.cpp	/^void biasVec(float* arr, int len, float bias)$/;"	f	namespace:booster
biasVec	booster/avx/generic_kernels.cpp	/^void biasVec(float* arr, int len, float bias)$/;"	f	namespace:booster
biasVecOpenmp	booster/arm/generic_kernels.cpp	/^void biasVecOpenmp(float* arr, int len, float bias, int nThreads)$/;"	f	namespace:booster
biasVecOpenmp	booster/avx/generic_kernels.cpp	/^void biasVecOpenmp(float* arr, int len, float bias, int nThreads)$/;"	f	namespace:booster
bias_data	layers/conv_layer.h	/^        float *bias_data;$/;"	m	class:feather::ConvLayer
bias_data	layers/inner_product_layer.h	/^        float *bias_data;$/;"	m	class:feather::InnerProductLayer
bias_mem	booster/include/booster/booster.h	/^    cl::Buffer* bias_mem;$/;"	m	struct:booster::CLBuffers
bias_term	booster/include/booster/booster.h	/^    bool bias_term;$/;"	m	struct:booster::ConvParam
bias_term	layers/inner_product_layer.h	/^        bool bias_term;$/;"	m	class:feather::InnerProductLayer
bias_term	layers/scale_layer.h	/^        int bias_term;$/;"	m	class:feather::ScaleLayer
binfp	ncnn/modelbin.h	/^    FILE* binfp;$/;"	m	class:ncnn::ModelBinFromStdio
blob_map	net.h	/^        std::map<std::string, Blob<float> *> blob_map;$/;"	m	class:feather::Net
block_sgemm	booster/arm/sgemm_legacy.cpp	/^void block_sgemm(int M, int N, int L, float *a, float *b, float *c)$/;"	f
block_sgemm_external_pack	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_external_pack(int M, int N, int L, float *a, float *b, float *c)$/;"	f
block_sgemm_external_pack_threading	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_external_pack_threading(int M, int N, int L, float *a, float *b, float *c, int num_threads)$/;"	f
block_sgemm_external_pack_threading_8x8	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_external_pack_threading_8x8(int M, int N, int L, float *a, float *b, float *c, int num_threads)$/;"	f
block_sgemm_internal_pack	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_internal_pack(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
block_sgemm_pack	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_pack(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
block_sgemm_pack_8x8	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_pack_8x8(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
block_sgemm_pack_8x8	booster/arm/sgemm_legacy.cpp	/^void block_sgemm_pack_8x8(int M, int N, int L, float *a, int lda, float *b, int ldb, float *c, int ldc, int num_threads)$/;"	f
block_size	ncnn/allocator.h	/^    size_t block_size;$/;"	m	class:ncnn::VkUnlockedBlobBufferAllocator
block_size	ncnn/allocator.h	/^    size_t block_size;$/;"	m	class:ncnn::VkWeightBufferAllocator
bn_kernel	layers/batchnorm_layer.h	/^        void (*bn_kernel)(const size_t channels, const size_t stride, const float* alpha, const float* beta, const float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads);$/;"	m	class:feather::BatchNormLayer
booster	booster/arm/booster.cpp	/^namespace booster$/;"	n	file:
booster	booster/arm/generic_kernels.cpp	/^namespace booster$/;"	n	file:
booster	booster/arm/sgeconv.cpp	/^namespace booster$/;"	n	file:
booster	booster/avx/booster.cpp	/^namespace booster$/;"	n	file:
booster	booster/avx/generic_kernels.cpp	/^namespace booster$/;"	n	file:
booster	booster/include/booster/booster.h	/^namespace booster$/;"	n
booster	booster/include/booster/generic_kernels.h	/^namespace booster$/;"	n
booster	booster/include/booster/sgeconv.h	/^namespace booster$/;"	n
bottoms	layer.h	/^        std::vector<Blob<float>* > bottoms;$/;"	m	class:feather::Layer
budgets	ncnn/allocator.h	/^    std::list< std::pair<size_t, void*> > budgets;$/;"	m	class:ncnn::PoolAllocator
budgets	ncnn/allocator.h	/^    std::list< std::pair<size_t, void*> > budgets;$/;"	m	class:ncnn::UnlockedPoolAllocator
budgets	ncnn/allocator.h	/^    std::list<VkBufferMemory*> budgets;$/;"	m	class:ncnn::VkUnlockedStagingBufferAllocator
budgets	ncnn/allocator.h	/^    std::vector< std::list< std::pair<size_t, size_t> > > budgets;$/;"	m	class:ncnn::VkUnlockedBlobBufferAllocator
budgets_lock	ncnn/allocator.h	/^    Mutex budgets_lock;$/;"	m	class:ncnn::PoolAllocator
budgets_lock	ncnn/allocator.h	/^    Mutex budgets_lock;$/;"	m	class:ncnn::VkBlobBufferAllocator
budgets_lock	ncnn/allocator.h	/^    Mutex budgets_lock;$/;"	m	class:ncnn::VkStagingBufferAllocator
buffer	ncnn/allocator.h	/^    VkBuffer buffer;$/;"	m	class:ncnn::VkBufferMemory
buffer_block_free_spaces	ncnn/allocator.h	/^    std::vector<size_t> buffer_block_free_spaces;$/;"	m	class:ncnn::VkWeightBufferAllocator
buffer_blocks	ncnn/allocator.h	/^    std::vector<VkBufferMemory*> buffer_blocks;$/;"	m	class:ncnn::VkUnlockedBlobBufferAllocator
buffer_blocks	ncnn/allocator.h	/^    std::vector<VkBufferMemory*> buffer_blocks;$/;"	m	class:ncnn::VkWeightBufferAllocator
buffer_offset_alignment	ncnn/allocator.h	/^    size_t buffer_offset_alignment;$/;"	m	class:ncnn::VkUnlockedBlobBufferAllocator
buffer_offset_alignment	ncnn/allocator.h	/^    size_t buffer_offset_alignment;$/;"	m	class:ncnn::VkWeightBufferAllocator
c	ncnn/mat.h	/^    int c;$/;"	m	class:ncnn::Mat
c_cephes_FOPI	booster/include/booster/power.h	204;"	d
c_cephes_LOG2EF	booster/include/booster/power.h	121;"	d
c_cephes_SQRTHF	booster/include/booster/power.h	31;"	d
c_cephes_exp_C1	booster/include/booster/power.h	122;"	d
c_cephes_exp_C2	booster/include/booster/power.h	123;"	d
c_cephes_exp_p0	booster/include/booster/power.h	125;"	d
c_cephes_exp_p1	booster/include/booster/power.h	126;"	d
c_cephes_exp_p2	booster/include/booster/power.h	127;"	d
c_cephes_exp_p3	booster/include/booster/power.h	128;"	d
c_cephes_exp_p4	booster/include/booster/power.h	129;"	d
c_cephes_exp_p5	booster/include/booster/power.h	130;"	d
c_cephes_log_p0	booster/include/booster/power.h	32;"	d
c_cephes_log_p1	booster/include/booster/power.h	33;"	d
c_cephes_log_p2	booster/include/booster/power.h	34;"	d
c_cephes_log_p3	booster/include/booster/power.h	35;"	d
c_cephes_log_p4	booster/include/booster/power.h	36;"	d
c_cephes_log_p5	booster/include/booster/power.h	37;"	d
c_cephes_log_p6	booster/include/booster/power.h	38;"	d
c_cephes_log_p7	booster/include/booster/power.h	39;"	d
c_cephes_log_p8	booster/include/booster/power.h	40;"	d
c_cephes_log_q1	booster/include/booster/power.h	41;"	d
c_cephes_log_q2	booster/include/booster/power.h	42;"	d
c_coscof_p0	booster/include/booster/power.h	201;"	d
c_coscof_p1	booster/include/booster/power.h	202;"	d
c_coscof_p2	booster/include/booster/power.h	203;"	d
c_exp_hi	booster/include/booster/power.h	118;"	d
c_exp_lo	booster/include/booster/power.h	119;"	d
c_inv_mant_mask	booster/include/booster/power.h	30;"	d
c_minus_cephes_DP1	booster/include/booster/power.h	195;"	d
c_minus_cephes_DP2	booster/include/booster/power.h	196;"	d
c_minus_cephes_DP3	booster/include/booster/power.h	197;"	d
c_sincof_p0	booster/include/booster/power.h	198;"	d
c_sincof_p1	booster/include/booster/power.h	199;"	d
c_sincof_p2	booster/include/booster/power.h	200;"	d
cache_block	booster/avx/winograd_kernels_F63.cpp	/^const int cache_block = 16;$/;"	v
caffe_cpu_interp2	booster/arm/caffe_interp.cpp	/^void caffe_cpu_interp2(const int channels,$/;"	f
caffe_cpu_interp2	booster/avx/caffe_interp.cpp	/^void caffe_cpu_interp2(const int channels,$/;"	f
capacity	ncnn/allocator.h	/^    size_t capacity;$/;"	m	class:ncnn::VkBufferMemory
cast_float16_to_float32	ncnn/mat.cpp	/^void cast_float16_to_float32(const Mat& src, Mat& dst, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
cast_float32_to_float16	ncnn/mat.cpp	/^void cast_float32_to_float16(const Mat& src, Mat& dst, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
channel	ncnn/mat.h	/^inline Mat Mat::channel(int _c)$/;"	f	class:ncnn::Mat
channel	ncnn/mat.h	/^inline const Mat Mat::channel(int _c) const$/;"	f	class:ncnn::Mat
channel_block_size	booster/include/booster/booster.h	/^    int channel_block_size;$/;"	m	struct:booster::ConvParam
channel_range	ncnn/mat.h	/^inline Mat Mat::channel_range(int _c, int channels)$/;"	f	class:ncnn::Mat
channel_range	ncnn/mat.h	/^inline const Mat Mat::channel_range(int _c, int channels) const$/;"	f	class:ncnn::Mat
channels	blob.h	/^        size_t channels() const$/;"	f	class:feather::Blob
channels	layers/batchnorm_layer.h	/^        int channels;$/;"	m	class:feather::BatchNormLayer
channels	layers/scale_layer.h	/^        size_t channels;$/;"	m	class:feather::ScaleLayer
clear	ncnn/allocator.cpp	/^void PoolAllocator::clear()$/;"	f	class:ncnn::PoolAllocator
clear	ncnn/allocator.cpp	/^void UnlockedPoolAllocator::clear()$/;"	f	class:ncnn::UnlockedPoolAllocator
clear	ncnn/allocator.h	/^    virtual void clear() {}$/;"	f	class:ncnn::VkAllocator
clear	ncnn/paramdict.cpp	/^void ParamDict::clear()$/;"	f	class:ncnn::ParamDict
clock_gettime	booster/avx/helper.cpp	/^int clock_gettime(int no_use, struct timespec *spec)$/;"	f
clone	ncnn/mat.h	/^inline Mat Mat::clone(Allocator* allocator) const$/;"	f	class:ncnn::Mat
common_memory	mempool.h	/^        PTR_TYPE * common_memory;$/;"	m	class:CommonMemPool
common_mempool	layer.h	/^        CommonMemPool<float>    *common_mempool;$/;"	m	class:feather::Layer
common_mempool	rt_param.h	/^        CommonMemPool<Dtype> *common_mempool() const$/;"	f	class:RuntimeParameter
common_ptr_map	mempool.h	/^        std::map<size_t, PTR_TYPE *> common_ptr_map;$/;"	m	class:CommonMemPool
common_size	mempool.h	/^        size_t common_size;$/;"	m	class:CommonMemPool
common_size_map	mempool.h	/^        std::map<size_t, size_t> common_size_map;$/;"	m	class:CommonMemPool
compute_block_activation	booster/arm/sgemm.cpp	/^inline void compute_block_activation(int M, int nc, int kc, float* packA, float* packB, float* loadC, float *C, int ldc, float* bias, int bias_len, InnerKernel inner_kernel_local)$/;"	f
compute_block_activation	booster/avx/sgeconv.cpp	/^inline void compute_block_activation(int M, int nc, int kc, float* packA, float* packB, float* loadC, float *C, int ldc, float* bias, int bias_len)$/;"	f
compute_block_activation	booster/avx/sgemm.cpp	/^inline void compute_block_activation(int M, int nc, int kc, float* packA, float* packB, float* loadC, float *C, int ldc, float* bias, int bias_len)$/;"	f
compute_block_activation_reduce_ldst	booster/arm/sgeconv.cpp	/^inline void compute_block_activation_reduce_ldst(int M, int nc, int kc, float* packA, float* packB, float *C, int ldc, float* bias, int bias_len, InnerKernel inner_kernel_local)$/;"	f	namespace:booster
condition	booster/include/booster/thpool.h	/^    std::condition_variable condition;$/;"	m	class:ThreadPool
conv_booster	layers/conv_layer.h	/^        booster::ConvBooster conv_booster;$/;"	m	class:feather::ConvLayer
conv_param	layers/conv_layer.h	/^        booster::ConvParam conv_param;$/;"	m	class:feather::ConvLayer
convert_packing	ncnn/mat.cpp	/^void convert_packing(const Mat& src, Mat& dst, int _packing, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
copy_cut_border	ncnn/mat.cpp	/^void copy_cut_border(const Mat& src, Mat& dst, int top, int bottom, int left, int right, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
copy_make_border	ncnn/mat.cpp	/^void copy_make_border(const Mat& src, Mat& dst, int top, int bottom, int left, int right, int type, float v, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
cos_ps	booster/include/booster/power.h	/^static inline float32x4_t cos_ps(float32x4_t x)$/;"	f
create	ncnn/mat.h	/^inline void Mat::create(int _w, int _h, int _c, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create	ncnn/mat.h	/^inline void Mat::create(int _w, int _h, int _c, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create	ncnn/mat.h	/^inline void Mat::create(int _w, int _h, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create	ncnn/mat.h	/^inline void Mat::create(int _w, int _h, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create	ncnn/mat.h	/^inline void Mat::create(int _w, size_t _elemsize, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create	ncnn/mat.h	/^inline void Mat::create(int _w, size_t _elemsize, int _packing, Allocator* _allocator)$/;"	f	class:ncnn::Mat
create_like	ncnn/mat.h	/^inline void Mat::create_like(const Mat& m, Allocator* _allocator)$/;"	f	class:ncnn::Mat
cstep	ncnn/mat.h	/^    size_t cstep;$/;"	m	class:ncnn::Mat
data	blob.h	/^        Dtype* data() const$/;"	f	class:feather::Blob
data	ncnn/mat.h	/^    void* data;$/;"	m	class:ncnn::Mat
data_size	blob.h	/^        size_t data_size() const$/;"	f	class:feather::Blob
dedicated_buffer_blocks	ncnn/allocator.h	/^    std::vector<VkBufferMemory*> dedicated_buffer_blocks;$/;"	m	class:ncnn::VkWeightBufferAllocator
diff	booster/arm/helper.cpp	/^void diff(float* arr1, float* arr2, int M, int N)$/;"	f
diff	booster/arm/helper.cpp	/^void diff(float* arr1, float* arr2, int len)$/;"	f
diff	booster/avx/helper.cpp	/^void diff(float* arr1, float* arr2, int M, int N)$/;"	f
diff	booster/avx/helper.cpp	/^void diff(float* arr1, float* arr2, int len)$/;"	f
dims	ncnn/mat.h	/^    int dims;$/;"	m	class:ncnn::Mat
div_ps	booster/include/booster/power.h	/^static inline float32x4_t div_ps(float32x4_t a, float32x4_t b)$/;"	f
dwConv_template	booster/arm/depthwise.cpp	/^void dwConv_template(float *output, float *input, int input_channels, int inw, int inh, int stridew, int strideh, float *kernel, int kw, int kh, int group, int nThreads, float *bias_arr)$/;"	f
dwConv_template	booster/avx/depthwise.cpp	/^void dwConv_template(float *output, float *input, int input_channels, int inw, int inh, int stridew, int strideh, float *kernel, int kw, int kh, int group, int nThreads, float *bias_arr)$/;"	f
dwConvs1	booster/arm/depthwise.cpp	/^void dwConvs1(float *output, float *input, int inw, int inh, int stridew, int strideh, float *kernel, int kw, int kh, int group, int nThreads, float *bias_arr)$/;"	f
dwConvs2	booster/arm/depthwise.cpp	/^void dwConvs2(float *output, float *input, int inw, int inh, int stridew, int strideh, float *kernel, int kw, int kh, int group, int nThreads, float *bias_arr)$/;"	f
elemsize	ncnn/mat.h	/^    size_t elemsize;$/;"	m	class:ncnn::Mat
empty	ncnn/mat.h	/^inline bool Mat::empty() const$/;"	f	class:ncnn::Mat
endBench	booster/arm/helper.cpp	/^double Timer::endBench()$/;"	f	class:Timer
endBench	booster/arm/helper.cpp	/^void Timer::endBench(const char* comment)$/;"	f	class:Timer
endBench	booster/arm/helper.cpp	/^void Timer::endBench(const char* comment, double fold)$/;"	f	class:Timer
endBench	booster/avx/helper.cpp	/^double Timer::endBench()$/;"	f	class:Timer
endBench	booster/avx/helper.cpp	/^void Timer::endBench(const char* comment)$/;"	f	class:Timer
endBench	booster/avx/helper.cpp	/^void Timer::endBench(const char* comment, double fold)$/;"	f	class:Timer
eps	layers/batchnorm_layer.h	/^        float eps;$/;"	m	class:feather::BatchNormLayer
exp_ps	booster/include/booster/power.h	/^static inline float32x4_t exp_ps(float32x4_t x)$/;"	f
externalPackA	booster/arm/sgemm_legacy.cpp	/^void externalPackA(int M, int L, float* packA, float* a, int lda)$/;"	f
externalPackA8	booster/arm/sgemm_legacy.cpp	/^void externalPackA8(int M, int L, float* packA, float* a, int lda)$/;"	f
f	ncnn/paramdict.h	/^        union { int i; float f; };$/;"	m	union:ncnn::ParamDict::__anon2::__anon3
fastFree	ncnn/allocator.cpp	/^void PoolAllocator::fastFree(void* ptr)$/;"	f	class:ncnn::PoolAllocator
fastFree	ncnn/allocator.cpp	/^void UnlockedPoolAllocator::fastFree(void* ptr)$/;"	f	class:ncnn::UnlockedPoolAllocator
fastFree	ncnn/allocator.h	/^static inline void fastFree(void* ptr)$/;"	f	namespace:ncnn
fastMalloc	ncnn/allocator.cpp	/^void* PoolAllocator::fastMalloc(size_t size)$/;"	f	class:ncnn::PoolAllocator
fastMalloc	ncnn/allocator.cpp	/^void* UnlockedPoolAllocator::fastMalloc(size_t size)$/;"	f	class:ncnn::UnlockedPoolAllocator
fastMalloc	ncnn/allocator.h	/^static inline void* fastMalloc(size_t size)$/;"	f	namespace:ncnn
feather	blob.cpp	/^namespace feather$/;"	n	file:
feather	blob.h	/^namespace feather$/;"	n
feather	layer.cpp	/^namespace feather$/;"	n	file:
feather	layer.h	/^namespace feather$/;"	n
feather	layer_factory.cpp	/^namespace feather$/;"	n	file:
feather	layer_factory.h	/^namespace feather$/;"	n
feather	layers/batchnorm_layer.h	/^namespace feather$/;"	n
feather	layers/concat_layer.h	/^namespace feather$/;"	n
feather	layers/conv_layer.h	/^namespace feather$/;"	n
feather	layers/dropout_layer.h	/^namespace feather$/;"	n
feather	layers/eltwise_layer.h	/^namespace feather$/;"	n
feather	layers/inner_product_layer.h	/^namespace feather$/;"	n
feather	layers/input_layer.h	/^namespace feather$/;"	n
feather	layers/pooling_layer.h	/^namespace feather$/;"	n
feather	layers/relu_layer.h	/^namespace feather$/;"	n
feather	layers/scale_layer.h	/^namespace feather$/;"	n
feather	layers/softmax_layer.h	/^namespace feather$/;"	n
feather	layers/split_layer.h	/^namespace feather$/;"	n
feather	net.cpp	/^namespace feather$/;"	n	file:
feather	net.h	/^namespace feather$/;"	n
feather_avx_load_padded_registers_8x8	booster/avx/winograd_kernels_F63_fused.cpp	/^inline void feather_avx_load_padded_registers_8x8($/;"	f	namespace:Winograd_F63_Fused
feather_mm256_get_mask	booster/avx/winograd_kernels_F63_fused.cpp	/^__m256i feather_mm256_get_mask(const int left_zeros, const int right_zeros)$/;"	f	namespace:Winograd_F63_Fused
fill	ncnn/mat.h	/^inline void Mat::fill(T _v)$/;"	f	class:ncnn::Mat
fill	ncnn/mat.h	/^inline void Mat::fill(float _v)$/;"	f	class:ncnn::Mat
fill	ncnn/mat.h	/^inline void Mat::fill(int _v)$/;"	f	class:ncnn::Mat
from_bgr2gray	ncnn/mat_pixel.cpp	/^static Mat from_bgr2gray(const unsigned char* bgr, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_float16	ncnn/mat.cpp	/^Mat Mat::from_float16(const unsigned short* data, int size)$/;"	f	class:ncnn::Mat
from_gray	ncnn/mat_pixel.cpp	/^static Mat from_gray(const unsigned char* gray, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_gray2rgb	ncnn/mat_pixel.cpp	/^static Mat from_gray2rgb(const unsigned char* gray, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_pixels	ncnn/mat_pixel.cpp	/^Mat Mat::from_pixels(const unsigned char* pixels, int type, int w, int h, Allocator* allocator)$/;"	f	class:ncnn::Mat
from_pixels_resize	ncnn/mat_pixel.cpp	/^Mat Mat::from_pixels_resize(const unsigned char* pixels, int type, int w, int h, int target_width, int target_height, Allocator* allocator)$/;"	f	class:ncnn::Mat
from_rgb	ncnn/mat_pixel.cpp	/^static Mat from_rgb(const unsigned char* rgb, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgb2bgr	ncnn/mat_pixel.cpp	/^static Mat from_rgb2bgr(const unsigned char* rgb, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgb2gray	ncnn/mat_pixel.cpp	/^static Mat from_rgb2gray(const unsigned char* rgb, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgba	ncnn/mat_pixel.cpp	/^static Mat from_rgba(const unsigned char* rgba, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgba2bgr	ncnn/mat_pixel.cpp	/^static Mat from_rgba2bgr(const unsigned char* rgba, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgba2gray	ncnn/mat_pixel.cpp	/^static Mat from_rgba2gray(const unsigned char* rgba, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
from_rgba2rgb	ncnn/mat_pixel.cpp	/^static Mat from_rgba2rgb(const unsigned char* rgba, int w, int h, Allocator* allocator)$/;"	f	namespace:ncnn
fully_connected_inference_direct	booster/arm/sgemv.cpp	/^void fully_connected_inference_direct(const int input_size, const int output_size, const float *x, const float *y, float *z, const int num_threads, float* bias_arr)$/;"	f
fully_connected_inference_direct	booster/avx/sgemv.cpp	/^void fully_connected_inference_direct(const int input_size, const int output_size, const float *x, const float *y, float *z, const int num_threads, float *bias_arr)$/;"	f
fully_connected_transpose_inference	booster/arm/sgemv.cpp	/^void fully_connected_transpose_inference(const int input_size, const int output_size, const float *x, const float *y, float *z, const int num_threads, float* bias_arr)$/;"	f
fully_connected_transpose_inference	booster/avx/sgemv.cpp	/^void fully_connected_transpose_inference(const int input_size, const int output_size, const float *x, const float *y, float *z, const int num_threads, float *bias_arr)$/;"	f
fuse_relu	layers/batchnorm_layer.h	/^        bool fuse_relu;$/;"	m	class:feather::BatchNormLayer
fuse_relu	layers/eltwise_layer.h	/^        int fuse_relu;$/;"	m	class:feather::EltwiseLayer
fuse_relu	layers/inner_product_layer.h	/^        bool fuse_relu;$/;"	m	class:feather::InnerProductLayer
fuse_scale	layers/batchnorm_layer.h	/^        bool fuse_scale;$/;"	m	class:feather::BatchNormLayer
fusible	layer.cpp	/^bool Layer::fusible() const$/;"	f	class:feather::Layer
future	booster/include/booster/thpool.h	/^        -> std::future<typename std::result_of<F(Args...)>::type>;$/;"	m	class:ThreadPool::std
get	ncnn/paramdict.cpp	/^Mat ParamDict::get(int id, const Mat& def) const$/;"	f	class:ncnn::ParamDict
get	ncnn/paramdict.cpp	/^float ParamDict::get(int id, float def) const$/;"	f	class:ncnn::ParamDict
get	ncnn/paramdict.cpp	/^int ParamDict::get(int id, int def) const$/;"	f	class:ncnn::ParamDict
getPackArraySize_F6x6_3x3	booster/arm/winograd_kernels_F63.cpp	/^size_t getPackArraySize_F6x6_3x3(int inChannels, int num_threads)$/;"	f
getPackArraySize_F6x6_3x3	booster/avx/winograd_kernels_F63.cpp	/^size_t getPackArraySize_F6x6_3x3(int inChannels, int num_threads)$/;"	f
getPackArraySize_F6x6_3x3	booster/avx/winograd_kernels_F63_fused.cpp	/^size_t getPackArraySize_F6x6_3x3(int inChannels, int num_threads)$/;"	f	namespace:Winograd_F63_Fused
get_innerkernel_4	booster/arm/sgemm_legacy.cpp	/^SGEMMInnerKernel get_innerkernel_4(int N)$/;"	f
get_innerkernel_8	booster/arm/sgemm_legacy.cpp	/^SGEMMInnerKernel get_innerkernel_8(int N)$/;"	f
get_kernel_Nx12	booster/arm/sgeconv.cpp	/^InnerKernel get_kernel_Nx12(int k)$/;"	f	namespace:booster
get_kernel_Nx12	booster/arm/sgemm.cpp	/^InnerKernel get_kernel_Nx12(int k)$/;"	f
get_kernel_Nx8	booster/arm/sgeconv.cpp	/^InnerKernel get_kernel_Nx8(int k)$/;"	f	namespace:booster
get_kernel_Nx8	booster/arm/sgemm.cpp	/^InnerKernel get_kernel_Nx8(int k)$/;"	f
get_mm_tail_mask	booster/avx/winograd_kernels_F63_fused.cpp	/^inline __m128i get_mm_tail_mask()$/;"	f	namespace:Winograd_F63_Fused
get_mm_tail_mask	booster/avx/winograd_kernels_F63_fused.cpp	/^inline __m128i get_mm_tail_mask(int zero_lane_cnt)$/;"	f	namespace:Winograd_F63_Fused
globalDwConv	booster/arm/depthwise.cpp	/^void globalDwConv(float *output, const float *input, int input_channels, int inw, int inh, float *kernel, int group, int nThreads, float *bias_arr)$/;"	f
globalDwConv	booster/avx/depthwise.cpp	/^void globalDwConv(float *output, const float *input, int input_channels, int inw, int inh, float *kernel, int group, int nThreads, float *bias_arr)$/;"	f
global_pooling	layers/pooling_layer.h	/^        bool global_pooling;$/;"	m	class:feather::PoolingLayer
group	booster/include/booster/booster.h	/^    int group;$/;"	m	struct:booster::ConvParam
h	ncnn/mat.h	/^    int h;$/;"	m	class:ncnn::Mat
half	utils.h	/^typedef unsigned short half;$/;"	t
half2float	ncnn/mat.cpp	/^static float half2float(unsigned short value)$/;"	f	namespace:ncnn
height	blob.h	/^        size_t height() const$/;"	f	class:feather::Blob
height_block_size	booster/include/booster/booster.h	/^    int height_block_size;$/;"	m	struct:booster::ConvParam
hs_floatToHalf	utils.cpp	/^unsigned short hs_floatToHalf(float f)$/;"	f
hs_halfToFloat	utils.cpp	/^float hs_halfToFloat(unsigned short c)$/;"	f
hs_halfToFloatRep	utils.cpp	/^int hs_halfToFloatRep(unsigned short c)$/;"	f
i	ncnn/paramdict.h	/^        union { int i; float f; };$/;"	m	union:ncnn::ParamDict::__anon2::__anon3
id_map	booster/include/booster/thpool.h	/^    std::map< std::thread::id, int > id_map;$/;"	m	class:ThreadPool
im2col	booster/arm/generic_kernels.cpp	/^void im2col(ConvParam *conv_param, float *img_buffer, float *input)$/;"	f	namespace:booster
im2col	booster/avx/generic_kernels.cpp	/^void im2col(ConvParam *conv_param, float *img_buffer, float *input)$/;"	f	namespace:booster
inner_kernel_4x12	booster/arm/sgeconv.cpp	/^void inner_kernel_4x12(int K, float *packA, float *packB, float *c, int ldc)$/;"	f	namespace:booster
inner_kernel_4x12	booster/arm/sgemm.cpp	/^void inner_kernel_4x12(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_8x12	booster/arm/sgeconv.cpp	/^void inner_kernel_8x12(int K, float *packA, float *packB, float *c, int ldc)$/;"	f	namespace:booster
inner_kernel_8x12	booster/arm/sgemm.cpp	/^void inner_kernel_8x12(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_8x8	booster/arm/sgeconv.cpp	/^void inner_kernel_8x8(int K, float *packA, float *packB, float *c, int ldc)$/;"	f	namespace:booster
inner_kernel_8x8	booster/arm/sgemm.cpp	/^void inner_kernel_8x8(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_Nx12_template	booster/arm/sgeconv.cpp	/^void inner_kernel_Nx12_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f	namespace:booster
inner_kernel_Nx12_template	booster/arm/sgemm.cpp	/^void inner_kernel_Nx12_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_Nx16	booster/avx/sgeconv.cpp	/^void (*inner_kernel_Nx16)(int K, float *packA, float *packB, float *c, int ldc);$/;"	v
inner_kernel_Nx16	booster/avx/sgemm.cpp	/^void (*inner_kernel_Nx16)(int K, float *packA, float *packB, float *c, int ldc);$/;"	v
inner_kernel_Nx16_template	booster/avx/sgeconv.cpp	/^void inner_kernel_Nx16_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_Nx16_template	booster/avx/sgemm.cpp	/^void inner_kernel_Nx16_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inner_kernel_Nx8_template	booster/arm/sgeconv.cpp	/^void inner_kernel_Nx8_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f	namespace:booster
inner_kernel_Nx8_template	booster/arm/sgemm.cpp	/^void inner_kernel_Nx8_template(int K, float *packA, float *packB, float *c, int ldc)$/;"	f
inputTransform	booster/arm/winograd_kernels.cpp	/^inline void inputTransform(float32x4_t &d0, float32x4_t &d1, float32x4_t &d2, float32x4_t &d3)$/;"	f
input_channels	booster/include/booster/booster.h	/^    int input_channels;$/;"	m	struct:booster::ConvParam
input_channels	layers/pooling_layer.h	/^        int input_channels;$/;"	m	class:feather::PoolingLayer
input_h	booster/include/booster/booster.h	/^    int input_h;$/;"	m	struct:booster::ConvParam
input_h	layers/pooling_layer.h	/^        int input_h;$/;"	m	class:feather::PoolingLayer
input_mem	booster/include/booster/booster.h	/^    cl::Buffer* input_mem;$/;"	m	struct:booster::CLBuffers
input_size	layers/inner_product_layer.h	/^        size_t input_size;$/;"	m	class:feather::InnerProductLayer
input_trans_mem	booster/include/booster/booster.h	/^    cl::Buffer* input_trans_mem;$/;"	m	struct:booster::CLBuffers
input_transform	booster/arm/winograd_kernels_F63.cpp	/^inline void input_transform($/;"	f
input_transform	booster/avx/winograd_kernels_F63.cpp	/^inline void input_transform($/;"	f
input_transform_avx	booster/avx/winograd_kernels_F63_fused.cpp	/^inline void input_transform_avx($/;"	f	namespace:Winograd_F63_Fused
input_w	booster/include/booster/booster.h	/^    int input_w;$/;"	m	struct:booster::ConvParam
input_w	layers/pooling_layer.h	/^        int input_w;$/;"	m	class:feather::PoolingLayer
internalPackA1	booster/arm/sgemm_legacy.cpp	/^void internalPackA1(int L, float* packA, float* a, int lda)$/;"	f
internalPackA2	booster/arm/sgemm_legacy.cpp	/^void internalPackA2(int L, float* packA, float* a, int lda)$/;"	f
internalPackA3	booster/arm/sgemm_legacy.cpp	/^void internalPackA3(int L, float* packA, float* a, int lda)$/;"	f
internalPackA4	booster/arm/sgemm_legacy.cpp	/^void internalPackA4(int L, float* packA, float* a, int lda)$/;"	f
internalPackA8	booster/arm/sgemm_legacy.cpp	/^void internalPackA8(int L, float* packA, float* a, int lda)$/;"	f
internalPackB4	booster/arm/sgemm_legacy.cpp	/^void internalPackB4(int L, float* packB, float* B, int ldb)$/;"	f
internalPackB8	booster/arm/sgemm_legacy.cpp	/^void internalPackB8(int L, float* packB, float* B, int ldb)$/;"	f
judge_android7_opencl	utils.cpp	/^bool judge_android7_opencl()$/;"	f
kc	booster/arm/sgemm_legacy.cpp	/^const int kc = 256;$/;"	v
kernel_data	layers/inner_product_layer.h	/^        float *kernel_data;$/;"	m	class:feather::InnerProductLayer
kernel_h	booster/include/booster/booster.h	/^    int kernel_h;$/;"	m	struct:booster::ConvParam
kernel_h	layers/pooling_layer.h	/^        int kernel_h;$/;"	m	class:feather::PoolingLayer
kernel_names	booster/include/booster/booster.h	/^        std::vector<std::string> kernel_names;$/;"	m	class:booster::ConvBoosterCL
kernel_w	booster/include/booster/booster.h	/^    int kernel_w;$/;"	m	struct:booster::ConvParam
kernel_w	layers/pooling_layer.h	/^        int kernel_w;$/;"	m	class:feather::PoolingLayer
layers	net.h	/^        std::vector<Layer *> layers;$/;"	m	class:feather::Net
load	ncnn/modelbin.cpp	/^Mat ModelBin::load(int w, int h, int c, int type) const$/;"	f	class:ncnn::ModelBin
load	ncnn/modelbin.cpp	/^Mat ModelBin::load(int w, int h, int type) const$/;"	f	class:ncnn::ModelBin
load	ncnn/modelbin.cpp	/^Mat ModelBinFromMatArray::load(int \/*w*\/, int \/*type*\/) const$/;"	f	class:ncnn::ModelBinFromMatArray
load	ncnn/modelbin.cpp	/^Mat ModelBinFromMemory::load(int w, int type) const$/;"	f	class:ncnn::ModelBinFromMemory
load	ncnn/modelbin.cpp	/^Mat ModelBinFromStdio::load(int w, int type) const$/;"	f	class:ncnn::ModelBinFromStdio
load_param	ncnn/paramdict.cpp	/^int ParamDict::load_param(FILE* fp)$/;"	f	class:ncnn::ParamDict
load_param	ncnn/paramdict.cpp	/^int ParamDict::load_param(const unsigned char*& mem)$/;"	f	class:ncnn::ParamDict
load_param_bin	ncnn/paramdict.cpp	/^int ParamDict::load_param_bin(FILE* fp)$/;"	f	class:ncnn::ParamDict
load_param_mem	ncnn/paramdict.cpp	/^int ParamDict::load_param_mem(const char*& mem)$/;"	f	class:ncnn::ParamDict
loaded	ncnn/paramdict.h	/^        int loaded;$/;"	m	struct:ncnn::ParamDict::__anon2
lock	ncnn/allocator.h	/^    void lock() { AcquireSRWLockExclusive(&srwlock); }$/;"	f	class:ncnn::Mutex
lock	ncnn/allocator.h	/^    void lock() { pthread_mutex_lock(&mutex); }$/;"	f	class:ncnn::Mutex
log_ps	booster/include/booster/power.h	/^static inline float32x4_t log_ps(float32x4_t x)$/;"	f
mappable	ncnn/allocator.h	/^    bool mappable;$/;"	m	class:ncnn::VkAllocator
mapped_ptr	ncnn/allocator.h	/^    void* mapped_ptr;$/;"	m	class:ncnn::VkBufferMemory
matrixTranspose	booster/arm/sgemv.cpp	/^void matrixTranspose(float* array, size_t m, size_t n, float *buffer)\/\/  A[m][n] -> A[n][m]$/;"	f
matrixTranspose	booster/avx/sgemv.cpp	/^void matrixTranspose(float *array, size_t m, size_t n, float *buffer) \/\/  A[m][n] -> A[n][m]$/;"	f
mc	booster/arm/sgemm_legacy.cpp	/^const int mc = 1024;$/;"	v
mem	ncnn/modelbin.h	/^    const unsigned char*& mem;$/;"	m	class:ncnn::ModelBinFromMemory
mem_sscanf	ncnn/paramdict.cpp	192;"	d	file:
mem_sscanf	ncnn/paramdict.cpp	195;"	d	file:
mem_sscanf_with_n	ncnn/paramdict.cpp	/^static inline int mem_sscanf_with_n(int* _internal_nconsumed_ptr, const char*& ptr, const char* format, ...)$/;"	f	namespace:ncnn
memcpy_floats_neon	booster/arm/sgeconv.cpp	/^void memcpy_floats_neon(float* dst, float* src, int len)$/;"	f	namespace:booster
memory	ncnn/allocator.h	/^    VkDeviceMemory memory;$/;"	m	class:ncnn::VkBufferMemory
memory_type_index	ncnn/allocator.h	/^    uint32_t memory_type_index;$/;"	m	class:ncnn::VkUnlockedStagingBufferAllocator
memory_type_index	ncnn/allocator.h	/^    uint32_t memory_type_index;$/;"	m	class:ncnn::VkWeightStagingBufferAllocator
memset_floats_neon	booster/arm/sgeconv.cpp	/^void memset_floats_neon(float* dst, int len)$/;"	f	namespace:booster
min	utils.cpp	/^int min(int a, int b)$/;"	f
mm_load_leftovers	booster/avx/winograd_kernels_F63_fused.cpp	/^inline void mm_load_leftovers(const float* &src, __m128& left, __m128& right, const int& load_cnt, const __m128i& mask)$/;"	f	namespace:Winograd_F63_Fused
mm_store_leftovers	booster/avx/winograd_kernels_F63_fused.cpp	/^inline void mm_store_leftovers(float* &dst, __m128& left, __m128& right, const int& store_cnt, const __m128i& mask)$/;"	f	namespace:Winograd_F63_Fused
mutex	ncnn/allocator.h	/^    Mutex& mutex;$/;"	m	class:ncnn::MutexLockGuard
mutex	ncnn/allocator.h	/^    pthread_mutex_t mutex;$/;"	m	class:ncnn::Mutex
naive_gemm	booster/arm/generic_kernels.cpp	/^void naive_gemm(int M, int N, int L, float *A, float *B, float *C)$/;"	f	namespace:booster
naive_gemm	booster/avx/generic_kernels.cpp	/^void naive_gemm(int M, int N, int L, float *A, float *B, float *C)$/;"	f	namespace:booster
naive_gemm_temp	booster/arm/winograd_kernels_F63.cpp	/^void naive_gemm_temp(int M, int N, int L, float *A, float *B, float *C)$/;"	f
naive_gemm_temp	booster/avx/winograd_kernels_F63.cpp	/^void naive_gemm_temp(int M, int N, int L, float *A, float *B, float *C)$/;"	f
naive_gemm_temp	booster/avx/winograd_kernels_F63_fused.cpp	/^void naive_gemm_temp(int M, int N, int L, float *A, float *B, float *C)$/;"	f	namespace:Winograd_F63_Fused
naive_sgemm	booster/arm/generic_kernels.cpp	/^void naive_sgemm(int M, int N, int L, float *A, float *B, float *C)$/;"	f	namespace:booster
naive_sgemm	booster/avx/generic_kernels.cpp	/^void naive_sgemm(int M, int N, int L, float *A, float *B, float *C)$/;"	f	namespace:booster
name	blob.h	/^        std::string name;$/;"	m	class:feather::Blob
name	layer.h	/^        std::string name;$/;"	m	class:feather::Layer
nc	booster/arm/sgemm_legacy.cpp	/^const int nc = 256;$/;"	v
ncnn	ncnn/allocator.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/allocator.h	/^namespace ncnn {$/;"	n
ncnn	ncnn/mat.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/mat.h	/^namespace ncnn {$/;"	n
ncnn	ncnn/mat_pixel.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/mat_pixel_resize.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/modelbin.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/modelbin.h	/^namespace ncnn {$/;"	n
ncnn	ncnn/paramdict.cpp	/^namespace ncnn {$/;"	n	file:
ncnn	ncnn/paramdict.h	/^namespace ncnn {$/;"	n
neon_transpose4x4_inplace_f32	booster/arm/winograd_kernels.cpp	/^static inline void neon_transpose4x4_inplace_f32($/;"	f	file:
neon_transpose4x4_inplace_f32_cpp	booster/arm/winograd_kernels_F63.cpp	/^static inline void neon_transpose4x4_inplace_f32_cpp($/;"	f	file:
neon_transpose4x4_inplace_f32_fp	booster/arm/winograd_kernels_F63.cpp	/^static inline void neon_transpose4x4_inplace_f32_fp(float *fp)$/;"	f	file:
num	blob.h	/^        size_t num() const$/;"	f	class:feather::Blob
num_threads	rt_param.h	/^        size_t num_threads() const$/;"	f	class:RuntimeParameter
offset	ncnn/allocator.h	/^    size_t offset;$/;"	m	class:ncnn::VkBufferMemory
op_type	layers/eltwise_layer.h	/^        int op_type;$/;"	m	class:feather::EltwiseLayer
operator =	ncnn/mat.h	/^inline Mat& Mat::operator=(const Mat& m)$/;"	f	class:ncnn::Mat
operator T*	ncnn/mat.h	/^inline Mat::operator T*()$/;"	f	class:ncnn::Mat
operator []	ncnn/mat.h	/^inline const float& Mat::operator[](int i) const$/;"	f	class:ncnn::Mat
operator []	ncnn/mat.h	/^inline float& Mat::operator[](int i)$/;"	f	class:ncnn::Mat
operator const T*	ncnn/mat.h	/^inline Mat::operator const T*() const$/;"	f	class:ncnn::Mat
out_trans_mem	booster/include/booster/booster.h	/^    cl::Buffer* out_trans_mem;$/;"	m	struct:booster::CLBuffers
output_channels	booster/include/booster/booster.h	/^    int output_channels;$/;"	m	struct:booster::ConvParam
output_channels	layers/pooling_layer.h	/^        int output_channels;$/;"	m	class:feather::PoolingLayer
output_h	booster/include/booster/booster.h	/^    int output_h;$/;"	m	struct:booster::ConvParam
output_h	layers/pooling_layer.h	/^        int output_h;$/;"	m	class:feather::PoolingLayer
output_mem	booster/include/booster/booster.h	/^    cl::Buffer* output_mem;$/;"	m	struct:booster::CLBuffers
output_size	layers/inner_product_layer.h	/^        size_t output_size;$/;"	m	class:feather::InnerProductLayer
output_w	booster/include/booster/booster.h	/^    int output_w;$/;"	m	struct:booster::ConvParam
output_w	layers/pooling_layer.h	/^        int output_w;$/;"	m	class:feather::PoolingLayer
pack_B_avx	booster/avx/sgeconv.cpp	/^void pack_B_avx(int kc, int nc, float* packB, float* B, int ldb)$/;"	f
pack_B_avx	booster/avx/sgemm.cpp	/^void pack_B_avx(int kc, int nc, float* packB, float* B, int ldb)$/;"	f
pack_B_im2col_neon	booster/arm/sgeconv.cpp	/^void pack_B_im2col_neon(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_neon_3x3s2	booster/arm/sgeconv.cpp	/^void pack_B_im2col_neon_3x3s2(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_neon_5x5s4	booster/arm/sgeconv.cpp	/^void pack_B_im2col_neon_5x5s4(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_neon_5x5s4p2	booster/arm/sgeconv.cpp	/^void pack_B_im2col_neon_5x5s4p2(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_scalar	booster/arm/sgeconv.cpp	/^void pack_B_im2col_scalar(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_scalar_v2	booster/arm/sgeconv.cpp	/^void pack_B_im2col_scalar_v2(ConvParam *conv_param, int kc, int nc, int nt, float* packB, float *B, int ldb)$/;"	f	namespace:booster
pack_B_im2col_stride_1_avx	booster/avx/sgeconv.cpp	/^void pack_B_im2col_stride_1_avx(booster::ConvParam *conv_param, int kc, int nc, int nt, float* packB, float* tB, float *B, int ldb)$/;"	f
pack_B_neon	booster/arm/sgeconv.cpp	/^void pack_B_neon(int kc, int nc, float* packB, float* B, int ldb)$/;"	f	namespace:booster
pack_B_neon	booster/arm/sgemm.cpp	/^void pack_B_neon(int kc, int nc, float* packB, float* B, int ldb)$/;"	f
packed_sgeconv_im2col_activation	booster/arm/sgeconv.cpp	/^void packed_sgeconv_im2col_activation(ConvParam *conv_param, float *packA, float *B, int ldb, float *C, int ldc, int nc, int kc, float* bias, int num_threads, float* pack_array)$/;"	f	namespace:booster
packed_sgeconv_im2col_activation	booster/avx/sgeconv.cpp	/^void packed_sgeconv_im2col_activation(booster::ConvParam *conv_param, float *packA, float *B, const int ldb, float *C, const int ldc, const int nc, const int kc, float* bias)$/;"	f
packed_sgeconv_init	booster/arm/sgeconv.cpp	/^void packed_sgeconv_init(ConvParam *conv_param, int kc, float* packA, float* A)$/;"	f	namespace:booster
packed_sgeconv_init	booster/avx/sgeconv.cpp	/^void packed_sgeconv_init(int M, int K, int kc, float* packA, float* A, int lda)$/;"	f
packed_sgemm_activation	booster/arm/sgemm.cpp	/^void packed_sgemm_activation(int M, int N, int K, float *packA, float *b, int ldb, float *c, int ldc, int nc, int kc, float* bias, int num_threads, float* pack_array)$/;"	f
packed_sgemm_activation	booster/avx/sgemm.cpp	/^void packed_sgemm_activation(int M, int N, int K, float *packA, float *b, int ldb, float *c, int ldc, int nc, int kc, float* bias, int num_threads, float* pack_array)$/;"	f
packed_sgemm_init	booster/arm/sgemm.cpp	/^void packed_sgemm_init(int M, int K, int kc, float* packA, float* A, int lda)$/;"	f
packed_sgemm_init	booster/avx/sgemm.cpp	/^void packed_sgemm_init(int M, int K, int kc, float* packA, float* A, int lda)$/;"	f
packing	ncnn/mat.h	/^    int packing;$/;"	m	class:ncnn::Mat
pad_bottom	booster/include/booster/booster.h	/^    int pad_bottom;$/;"	m	struct:booster::ConvParam
pad_bottom	layers/pooling_layer.h	/^        int pad_bottom;$/;"	m	class:feather::PoolingLayer
pad_input	booster/arm/generic_kernels.cpp	/^void pad_input(float* padded, const float* input, const size_t input_channels, const size_t input_width, const size_t input_height, const size_t padding_left, const size_t padding_top, const size_t padding_right, const size_t padding_bottom)$/;"	f	namespace:booster
pad_input	booster/avx/generic_kernels.cpp	/^void pad_input(float* padded, const float* input, const size_t input_channels, const size_t input_width, const size_t input_height, const size_t padding_left, const size_t padding_top, const size_t padding_right, const size_t padding_bottom)$/;"	f	namespace:booster
pad_input_neon	booster/arm/sgeconv.cpp	/^void pad_input_neon(ConvParam *conv_param, float* padded_input, float* input)$/;"	f	namespace:booster
pad_left	booster/include/booster/booster.h	/^    int pad_left;$/;"	m	struct:booster::ConvParam
pad_left	layers/pooling_layer.h	/^        int pad_left;$/;"	m	class:feather::PoolingLayer
pad_right	booster/include/booster/booster.h	/^    int pad_right;$/;"	m	struct:booster::ConvParam
pad_right	layers/pooling_layer.h	/^        int pad_right;$/;"	m	class:feather::PoolingLayer
pad_top	booster/include/booster/booster.h	/^    int pad_top;$/;"	m	struct:booster::ConvParam
pad_top	layers/pooling_layer.h	/^        int pad_top;$/;"	m	class:feather::PoolingLayer
padded_input_channels	booster/include/booster/booster.h	/^    int padded_input_channels;$/;"	m	struct:booster::ConvParam
padded_input_h	booster/include/booster/booster.h	/^    int padded_input_h;$/;"	m	struct:booster::ConvParam
padded_input_mem	booster/include/booster/booster.h	/^    cl::Buffer* padded_input_mem;$/;"	m	struct:booster::CLBuffers
padded_input_w	booster/include/booster/booster.h	/^    int padded_input_w;$/;"	m	struct:booster::ConvParam
padded_output_channels	booster/include/booster/booster.h	/^    int padded_output_channels;$/;"	m	struct:booster::ConvParam
padded_output_h	booster/include/booster/booster.h	/^    int padded_output_h;$/;"	m	struct:booster::ConvParam
padded_output_w	booster/include/booster/booster.h	/^    int padded_output_w;$/;"	m	struct:booster::ConvParam
padding_needed	booster/include/booster/booster.h	/^    bool padding_needed;$/;"	m	struct:booster::ConvParam
params	ncnn/paramdict.h	/^    } params[NCNN_MAX_PARAM_COUNT];$/;"	m	class:ncnn::ParamDict	typeref:struct:ncnn::ParamDict::__anon2
payouts	ncnn/allocator.h	/^    std::list< std::pair<size_t, void*> > payouts;$/;"	m	class:ncnn::PoolAllocator
payouts	ncnn/allocator.h	/^    std::list< std::pair<size_t, void*> > payouts;$/;"	m	class:ncnn::UnlockedPoolAllocator
payouts_lock	ncnn/allocator.h	/^    Mutex payouts_lock;$/;"	m	class:ncnn::PoolAllocator
pooling_type	layers/pooling_layer.h	/^        int pooling_type;$/;"	m	class:feather::PoolingLayer
pow_ps	booster/include/booster/power.h	/^static inline float32x4_t pow_ps(float32x4_t a, float32x4_t b)$/;"	f
print_arr	booster/arm/helper.cpp	/^void print_arr(float* vp)$/;"	f
print_arr	booster/avx/helper.cpp	/^void print_arr(float* vp)$/;"	f
print_floats	booster/arm/helper.cpp	/^void print_floats(const float* arr, const int dimX, const int dimY)$/;"	f
print_floats	booster/arm/helper.cpp	/^void print_floats(const float* arr, const int len)$/;"	f
print_floats	booster/avx/helper.cpp	/^void print_floats(const float* arr, const int dimX, const int dimY)$/;"	f
print_floats	booster/avx/helper.cpp	/^void print_floats(const float* arr, const int len)$/;"	f
print_vec	booster/arm/helper.cpp	/^void print_vec(float32x4_t* vp)$/;"	f
print_vec	booster/arm/helper.cpp	/^void print_vec(float32x4_t* vp, const char* comment)$/;"	f
print_vec2	booster/arm/helper.cpp	/^void print_vec2(float32x4_t* vp)$/;"	f
print_vec3	booster/arm/helper.cpp	/^void print_vec3(float32x4_t* vp)$/;"	f
processed_kernel	layers/conv_layer.h	/^        float *processed_kernel;$/;"	m	class:feather::ConvLayer
program_names	booster/include/booster/booster.h	/^        std::vector<std::string> program_names;$/;"	m	class:booster::ConvBoosterCL
queue_mutex	booster/include/booster/thpool.h	/^    std::mutex queue_mutex;$/;"	m	class:ThreadPool
range	ncnn/mat.h	/^inline Mat Mat::range(int x, int n)$/;"	f	class:ncnn::Mat
range	ncnn/mat.h	/^inline const Mat Mat::range(int x, int n) const$/;"	f	class:ncnn::Mat
refcount	ncnn/allocator.h	/^    int refcount;$/;"	m	class:ncnn::VkBufferMemory
refcount	ncnn/mat.h	/^    int* refcount;$/;"	m	class:ncnn::Mat
register_layer_creators	layer_factory.cpp	/^void register_layer_creators()$/;"	f	namespace:feather
release	ncnn/mat.h	/^inline void Mat::release()$/;"	f	class:ncnn::Mat
relu	booster/arm/generic_kernels.cpp	/^void relu(float* arr, int len)$/;"	f	namespace:booster
relu	booster/avx/generic_kernels.cpp	/^void relu(float* arr, int len)$/;"	f	namespace:booster
reluVec	booster/arm/generic_kernels.cpp	/^void reluVec(float* arr, int len)$/;"	f	namespace:booster
reluVec	booster/avx/generic_kernels.cpp	/^void reluVec(float* arr, int len)$/;"	f	namespace:booster
reluVecOpenmp	booster/arm/generic_kernels.cpp	/^void reluVecOpenmp(float* arr, int len, int nThreads)$/;"	f	namespace:booster
reluVecOpenmp	booster/avx/generic_kernels.cpp	/^void reluVecOpenmp(float* arr, int len, int nThreads)$/;"	f	namespace:booster
reshape	ncnn/mat.h	/^inline Mat Mat::reshape(int _w, Allocator* _allocator) const$/;"	f	class:ncnn::Mat
reshape	ncnn/mat.h	/^inline Mat Mat::reshape(int _w, int _h, Allocator* _allocator) const$/;"	f	class:ncnn::Mat
reshape	ncnn/mat.h	/^inline Mat Mat::reshape(int _w, int _h, int _c, Allocator* _allocator) const$/;"	f	class:ncnn::Mat
resize_bicubic	ncnn/mat.cpp	/^void resize_bicubic(const Mat& src, Mat& dst, int w, int h, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
resize_bilinear	ncnn/mat.cpp	/^void resize_bilinear(const Mat& src, Mat& dst, int w, int h, Allocator* allocator, int num_threads)$/;"	f	namespace:ncnn
resize_bilinear_c1	ncnn/mat_pixel_resize.cpp	/^void resize_bilinear_c1(const unsigned char* src, int srcw, int srch, unsigned char* dst, int w, int h)$/;"	f	namespace:ncnn
resize_bilinear_c2	ncnn/mat_pixel_resize.cpp	/^void resize_bilinear_c2(const unsigned char* src, int srcw, int srch, unsigned char* dst, int w, int h)$/;"	f	namespace:ncnn
resize_bilinear_c3	ncnn/mat_pixel_resize.cpp	/^void resize_bilinear_c3(const unsigned char* src, int srcw, int srch, unsigned char* dst, int w, int h)$/;"	f	namespace:ncnn
resize_bilinear_c4	ncnn/mat_pixel_resize.cpp	/^void resize_bilinear_c4(const unsigned char* src, int srcw, int srch, unsigned char* dst, int w, int h)$/;"	f	namespace:ncnn
resize_bilinear_yuv420sp	ncnn/mat_pixel_resize.cpp	/^void resize_bilinear_yuv420sp(const unsigned char* src, int srcw, int srch, unsigned char* dst, int w, int h)$/;"	f	namespace:ncnn
row	ncnn/mat.h	/^inline T* Mat::row(int y)$/;"	f	class:ncnn::Mat
row	ncnn/mat.h	/^inline const T* Mat::row(int y) const$/;"	f	class:ncnn::Mat
row	ncnn/mat.h	/^inline const float* Mat::row(int y) const$/;"	f	class:ncnn::Mat
row	ncnn/mat.h	/^inline float* Mat::row(int y)$/;"	f	class:ncnn::Mat
row_range	ncnn/mat.h	/^inline Mat Mat::row_range(int y, int rows)$/;"	f	class:ncnn::Mat
row_range	ncnn/mat.h	/^inline const Mat Mat::row_range(int y, int rows) const$/;"	f	class:ncnn::Mat
rt_param	layer.h	/^        RuntimeParameter<float> *rt_param;$/;"	m	class:feather::Layer
rt_param	net.h	/^        RuntimeParameter<float> *rt_param;$/;"	m	class:feather::Net
scale	booster/arm/generic_kernels.cpp	/^void scale(const size_t channels, const size_t stride, const float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads)$/;"	f	namespace:booster
scale	booster/avx/generic_kernels.cpp	/^void scale(const size_t channels, const size_t stride, const float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads)$/;"	f	namespace:booster
scale	layers/dropout_layer.h	/^        float scale;$/;"	m	class:feather::DropoutLayer
scale_bias_term	layers/batchnorm_layer.h	/^        bool scale_bias_term;$/;"	m	class:feather::BatchNormLayer
scale_data_size	layers/scale_layer.h	/^        int scale_data_size;$/;"	m	class:feather::ScaleLayer
scale_kernel	layers/scale_layer.h	/^        void (*scale_kernel)(const size_t channels, const size_t stride, const  float* bias_data, const float* scale_data, const float* input, float* output, const size_t num_threads);$/;"	m	class:feather::ScaleLayer
set	ncnn/paramdict.cpp	/^void ParamDict::set(int id, const Mat& v)$/;"	f	class:ncnn::ParamDict
set	ncnn/paramdict.cpp	/^void ParamDict::set(int id, float f)$/;"	f	class:ncnn::ParamDict
set	ncnn/paramdict.cpp	/^void ParamDict::set(int id, int i)$/;"	f	class:ncnn::ParamDict
set_kernel	booster/avx/sgeconv.cpp	/^void set_kernel(int k)$/;"	f
set_kernel	booster/avx/sgemm.cpp	/^void set_kernel(int k)$/;"	f
set_size_compare_ratio	ncnn/allocator.cpp	/^void PoolAllocator::set_size_compare_ratio(float scr)$/;"	f	class:ncnn::PoolAllocator
set_size_compare_ratio	ncnn/allocator.cpp	/^void UnlockedPoolAllocator::set_size_compare_ratio(float scr)$/;"	f	class:ncnn::UnlockedPoolAllocator
sgemm_4x1	booster/arm/sgemm_legacy.cpp	/^void sgemm_4x1(int L, float *a, int lda, float* b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x2	booster/arm/sgemm_legacy.cpp	/^void sgemm_4x2(int L, float *a, int lda, float* b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x3	booster/arm/sgemm_legacy.cpp	/^void sgemm_4x3(int L, float *a, int lda, float* b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x4	booster/arm/sgemm_legacy.cpp	/^inline void sgemm_4x4(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x4_pack	booster/arm/sgemm_legacy.cpp	/^void sgemm_4x4_pack(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x5	booster/arm/sgemm_legacy.cpp	/^inline void sgemm_4x5(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x6	booster/arm/sgemm_legacy.cpp	/^inline void sgemm_4x6(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x7	booster/arm/sgemm_legacy.cpp	/^inline void sgemm_4x7(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_4x8_pack	booster/arm/sgemm_legacy.cpp	/^void sgemm_4x8_pack(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x1	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x1(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x2	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x2(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x3	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x3(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x4	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x4(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x5	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x5(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x6	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x6(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x7	booster/arm/sgemm_legacy.cpp	/^void sgemm_8x7(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemm_8x8_pack	booster/arm/sgemm_legacy.cpp	/^inline void sgemm_8x8_pack(int L, float *a, int lda, float *b, int ldb, float *c, int ldc)$/;"	f
sgemv_kernel	layers/inner_product_layer.h	/^        void (*sgemv_kernel)(const int, const int, const float *, const float *, float *, const int, float*);$/;"	m	class:feather::InnerProductLayer
sin_ps	booster/include/booster/power.h	/^static inline float32x4_t sin_ps(float32x4_t x)$/;"	f
sincos_ps	booster/include/booster/power.h	/^static inline void sincos_ps(float32x4_t x, float32x4_t *ysin, float32x4_t *ycos)$/;"	f
size_compare_ratio	ncnn/allocator.h	/^    unsigned int size_compare_ratio;\/\/ 0~256$/;"	m	class:ncnn::PoolAllocator
size_compare_ratio	ncnn/allocator.h	/^    unsigned int size_compare_ratio;\/\/ 0~256$/;"	m	class:ncnn::UnlockedPoolAllocator
size_compare_ratio	ncnn/allocator.h	/^    unsigned int size_compare_ratio;\/\/ 0~256$/;"	m	class:ncnn::VkUnlockedStagingBufferAllocator
softmax	booster/arm/generic_kernels.cpp	/^void softmax(float* input, float n)$/;"	f	namespace:booster
softmax	booster/avx/generic_kernels.cpp	/^void softmax(float* input, float n)$/;"	f	namespace:booster
srwlock	ncnn/allocator.h	/^    SRWLOCK srwlock;$/;"	m	class:ncnn::Mutex
start	booster/include/booster/helper.h	/^        timespec start, stop;$/;"	m	class:Timer
startBench	booster/arm/helper.cpp	/^void Timer::startBench()$/;"	f	class:Timer
startBench	booster/avx/helper.cpp	/^void Timer::startBench()$/;"	f	class:Timer
state	ncnn/allocator.h	/^    mutable int state;$/;"	m	class:ncnn::VkBufferMemory
stop	booster/include/booster/helper.h	/^        timespec start, stop;$/;"	m	class:Timer
stop	booster/include/booster/thpool.h	/^    bool stop;$/;"	m	class:ThreadPool
stride_h	booster/include/booster/booster.h	/^    int stride_h;$/;"	m	struct:booster::ConvParam
stride_h	layers/pooling_layer.h	/^        int stride_h;$/;"	m	class:feather::PoolingLayer
stride_w	booster/include/booster/booster.h	/^    int stride_w;$/;"	m	struct:booster::ConvParam
stride_w	layers/pooling_layer.h	/^        int stride_w;$/;"	m	class:feather::PoolingLayer
substract_mean_normalize	ncnn/mat.cpp	/^void Mat::substract_mean_normalize(const float* mean_vals, const float* norm_vals)$/;"	f	class:ncnn::Mat
tasks	booster/include/booster/thpool.h	/^    std::queue< std::function<void()> > tasks;$/;"	m	class:ThreadPool
tf_pad_mode	layers/pooling_layer.h	/^        int tf_pad_mode;$/;"	m	class:feather::PoolingLayer
threadID	booster/include/booster/thpool.h	/^inline int ThreadPool::threadID(std::thread::id std_id)$/;"	f	class:ThreadPool
threadNum	booster/include/booster/thpool.h	/^inline size_t ThreadPool::threadNum()$/;"	f	class:ThreadPool
to_bgr2rgb	ncnn/mat_pixel.cpp	/^static void to_bgr2rgb(const Mat& m, unsigned char* rgb)$/;"	f	namespace:ncnn
to_gray	ncnn/mat_pixel.cpp	/^static void to_gray(const Mat& m, unsigned char* gray)$/;"	f	namespace:ncnn
to_pixels	ncnn/mat_pixel.cpp	/^void Mat::to_pixels(unsigned char* pixels, int type) const$/;"	f	class:ncnn::Mat
to_pixels_resize	ncnn/mat_pixel.cpp	/^void Mat::to_pixels_resize(unsigned char* pixels, int type, int target_width, int target_height) const$/;"	f	class:ncnn::Mat
to_rgb	ncnn/mat_pixel.cpp	/^static void to_rgb(const Mat& m, unsigned char* rgb)$/;"	f	namespace:ncnn
to_rgba	ncnn/mat_pixel.cpp	/^static void to_rgba(const Mat& m, unsigned char* rgba)$/;"	f	namespace:ncnn
tops	layer.h	/^        std::vector<Blob<float>* > tops;$/;"	m	class:feather::Layer
total	ncnn/mat.h	/^inline size_t Mat::total() const$/;"	f	class:ncnn::Mat
transformKernel	booster/arm/winograd_kernels.cpp	/^void transformKernel(float* UT, float* kernel, int inChannels, int outChannels, float* ST)$/;"	f
transformKernel_F6x6_3x3	booster/arm/winograd_kernels_F63.cpp	/^void transformKernel_F6x6_3x3(float *UT, float *kernel, int inChannels, int outChannels)$/;"	f
transformKernel_F6x6_3x3	booster/avx/winograd_kernels_F63.cpp	/^void transformKernel_F6x6_3x3(float *UT, float *kernel, int inChannels, int outChannels)$/;"	f
transformKernel_F6x6_3x3	booster/avx/winograd_kernels_F63_fused.cpp	/^void transformKernel_F6x6_3x3(float *UT, float *kernel, int input_channels, int outChannels)$/;"	f	namespace:Winograd_F63_Fused
transpose8_avx_ps	booster/avx/winograd_kernels_F63_fused.cpp	/^inline void transpose8_avx_ps($/;"	f	namespace:Winograd_F63_Fused
transpose_temp	booster/arm/winograd_kernels_F63.cpp	/^void transpose_temp(size_t m, size_t n, float *in, float *out) \/\/  A[m][n] -> A[n][m]$/;"	f
transpose_temp	booster/avx/winograd_kernels_F63.cpp	/^void transpose_temp(size_t m, size_t n, float *in, float *out) \/\/  A[m][n] -> A[n][m]$/;"	f
transpose_temp	booster/avx/winograd_kernels_F63_fused.cpp	/^void transpose_temp(size_t m, size_t n, float *in, float *out) \/\/  A[m][n] -> A[n][m]$/;"	f	namespace:Winograd_F63_Fused
type	layer.h	/^        std::string type;$/;"	m	class:feather::Layer
unlock	ncnn/allocator.h	/^    void unlock() { ReleaseSRWLockExclusive(&srwlock); }$/;"	f	class:ncnn::Mutex
unlock	ncnn/allocator.h	/^    void unlock() { pthread_mutex_unlock(&mutex); }$/;"	f	class:ncnn::Mutex
use_int8_inference	ncnn/paramdict.h	/^    int use_int8_inference;$/;"	m	class:ncnn::ParamDict
use_sgemm_convolution	ncnn/paramdict.h	/^    int use_sgemm_convolution;$/;"	m	class:ncnn::ParamDict
use_vulkan_compute	ncnn/paramdict.h	/^    int use_vulkan_compute;$/;"	m	class:ncnn::ParamDict
use_winograd_convolution	ncnn/paramdict.h	/^    int use_winograd_convolution;$/;"	m	class:ncnn::ParamDict
v	ncnn/paramdict.h	/^        Mat v;$/;"	m	struct:ncnn::ParamDict::__anon2
vec	booster/avx/winograd_kernels_F63_fused.cpp	/^    __m256i vec;$/;"	m	union:Winograd_F63_Fused::MM256_ARRAY_UNION	file:
vfmaq_laneq_f32	booster/include/booster/helper.h	/^static inline float32x4_t vfmaq_laneq_f32(float32x4_t _s, float32x4_t _a, float32x4_t _b, int lane)$/;"	f
vkdev	ncnn/allocator.h	/^    const VulkanDevice* vkdev;$/;"	m	class:ncnn::VkAllocator
vmul	booster/arm/generic_kernels.cpp	/^void vmul(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
vmul	booster/avx/generic_kernels.cpp	/^void vmul(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
vstr_is_float	ncnn/paramdict.cpp	/^static bool vstr_is_float(const char vstr[16])$/;"	f	namespace:ncnn
vsub	booster/arm/generic_kernels.cpp	/^void vsub(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
vsub	booster/avx/generic_kernels.cpp	/^void vsub(float* dst, float* A, float* B, size_t len, size_t num_threads)$/;"	f	namespace:booster
w	ncnn/mat.h	/^    int w;$/;"	m	class:ncnn::Mat
weight_data_size	layers/inner_product_layer.h	/^        size_t weight_data_size;$/;"	m	class:feather::InnerProductLayer
weight_mem	booster/include/booster/booster.h	/^    cl::Buffer* weight_mem;$/;"	m	struct:booster::CLBuffers
weight_size	booster/include/booster/booster.h	/^        size_t weight_size;$/;"	m	class:booster::ConvBoosterCL
weights	layer.h	/^        std::vector<Blob<float>* > weights;$/;"	m	class:feather::Layer
weights	ncnn/modelbin.h	/^    mutable const Mat* weights;$/;"	m	class:ncnn::ModelBinFromMatArray
width	blob.h	/^        size_t width() const$/;"	f	class:feather::Blob
width_block_size	booster/include/booster/booster.h	/^    int width_block_size;$/;"	m	struct:booster::ConvParam
winogradInputFrameTransform	booster/arm/winograd_kernels.cpp	/^void winogradInputFrameTransform(float* VT, int ldvt, int inChannels, float* input, int frameStride, int ldin, int nRowBlocks, int nColBlocks)$/;"	f
winogradInputFrameTransformSeq	booster/arm/winograd_kernels_F63.cpp	/^void winogradInputFrameTransformSeq(float *VT, int inChannels, float *input, int inputh, int inputw, int frameStride, int ldin, int nRowBlocks, int nColBlocks, float* ext, int num_threads)$/;"	f
winogradInputFrameTransformSeq	booster/avx/winograd_kernels_F63.cpp	/^void winogradInputFrameTransformSeq(float *VT, int inChannels, float *input, int inputh, int inputw, int frameStride, int ldin, int nRowBlocks, int nColBlocks, int num_threads)$/;"	f
winogradInputFrameTransformStride	booster/arm/winograd_kernels.cpp	/^void winogradInputFrameTransformStride(float* VT, int ldvt, int inChannels, float* input, int frameStride, int ldin, int nRowBlocks, int nColBlocks, int num_threads)$/;"	f
winogradInputTransformSeqFusedAVX4	booster/avx/winograd_kernels_F63_fused.cpp	/^void winogradInputTransformSeqFusedAVX4(booster::ConvParam* conv_param, float *VT, const float *input, int startIdx, int endIdx, int channel_cache_block)$/;"	f	namespace:Winograd_F63_Fused
winogradKernelTransform	booster/arm/winograd_kernels.cpp	/^void winogradKernelTransform(float* transKernel, float* kernel)$/;"	f
winogradKernelTransformPacked	booster/arm/winograd_kernels_F63.cpp	/^void winogradKernelTransformPacked(float *transKernel, float *kernel, int stride, float* base, int oi, int oj)$/;"	f
winogradKernelTransformPacked	booster/avx/winograd_kernels_F63.cpp	/^void winogradKernelTransformPacked(float *transKernel, float *kernel, int stride, float* base, int oi, int oj)$/;"	f
winogradKernelTransformPacked	booster/avx/winograd_kernels_F63_fused.cpp	/^void winogradKernelTransformPacked(float *transKernel, float *kernel, int stride, float *base, int oi, int oj)$/;"	f	namespace:Winograd_F63_Fused
winogradKernelTransformStride	booster/arm/winograd_kernels.cpp	/^void winogradKernelTransformStride(float* transKernel[4], float* kernel)$/;"	f
winogradKernelTransform_F6x6_3x3	booster/arm/winograd_kernels_F63.cpp	/^void winogradKernelTransform_F6x6_3x3(float *transKernel, float *kernel)$/;"	f
winogradKernelTransform_F6x6_3x3	booster/avx/winograd_kernels_F63.cpp	/^void winogradKernelTransform_F6x6_3x3(float *transKernel, float *kernel)$/;"	f
winogradKernelTransform_F6x6_3x3	booster/avx/winograd_kernels_F63_fused.cpp	/^void winogradKernelTransform_F6x6_3x3(float *transKernel, float *kernel)$/;"	f	namespace:Winograd_F63_Fused
winogradNonFusedTransform	booster/arm/winograd_kernels.cpp	/^void winogradNonFusedTransform(float *output, int outChannels, float* WT, float* VT, float* UT, float* input, int inChannels, int inputw, int inputh, WinogradOutType outType, float* biasArr, int num_threads)$/;"	f
winogradNonFusedTransformMT_inner	booster/arm/winograd_kernels.cpp	/^void winogradNonFusedTransformMT_inner(float *output, int ldout, float* WT, float* VT, int ldvt, float* UT, int ldut, int inChannels, int outChannels, float* input, int frameStride, int ldin, int nRowBlocks, int nColBlocks, WinogradOutType outType, float* biasArr, int num_threads)$/;"	f
winogradNonFusedTransform_F6x6_3x3	booster/arm/winograd_kernels_F63.cpp	/^void winogradNonFusedTransform_F6x6_3x3(float *output, int outChannels, float *WT, float *VT, float *UT, float *input, int inChannels, int inputh, int inputw, WinogradOutType outType, float *biasArr, float* pack_array, int num_threads)$/;"	f
winogradNonFusedTransform_F6x6_3x3	booster/avx/winograd_kernels_F63.cpp	/^void winogradNonFusedTransform_F6x6_3x3(float *output, int outChannels, float *WT, float *VT, float *UT, float *input, int inChannels, int inputh, int inputw, WinogradOutType outType, float *biasArr, float* pack_array, int num_threads)$/;"	f
winogradNonFusedTransform_inner	booster/arm/winograd_kernels.cpp	/^void winogradNonFusedTransform_inner(float *output, int ldout, float* WT, float* VT, int ldvt, float* UT, int ldut, int inChannels, int outChannels, float* input, int frameStride, int ldin, int nRowBlocks, int nColBlocks, WinogradOutType outType, float* biasArr)$/;"	f
winogradNonFusedTransform_inner	booster/arm/winograd_kernels_F63.cpp	/^void winogradNonFusedTransform_inner(float *output, int ldout, float *WT, float *VT, float *UT, int inChannels, int outChannels, float *input, int inputh, int inputw, int frameStride, int ldin, int nRowBlocks, int nColBlocks, WinogradOutType outType, float *biasArr, float* pack_array, int num_threads)$/;"	f
winogradNonFusedTransform_inner	booster/avx/winograd_kernels_F63.cpp	/^void winogradNonFusedTransform_inner(float *output, int ldout, float *WT, float *VT, float *UT, int inChannels, int outChannels, float *input, int inputh, int inputw, int frameStride, int ldin, int nRowBlocks, int nColBlocks, WinogradOutType outType, float *biasArr, float* pack_array, int num_threads)$/;"	f
winogradOutputTransform	booster/arm/winograd_kernels.cpp	/^void winogradOutputTransform(float* output, int ldout, float* WT, int outChannels, int nRowBlocks, int nColBlocks, int num_threads)$/;"	f
winogradOutputTransform	booster/arm/winograd_kernels_F63.cpp	/^void winogradOutputTransform(float *output, int outputh, int outputw, int ldout, float *WT, int outChannels, int nRowBlocks, int nColBlocks, float* biasArr, float* ext, int num_threads)$/;"	f
winogradOutputTransform	booster/avx/winograd_kernels_F63.cpp	/^void winogradOutputTransform(float *output, int outputh, int outputw, int ldout, float *WT, int outChannels, int nRowBlocks, int nColBlocks, float* biasArr, int num_threads)$/;"	f
winogradOutputTransformBias	booster/arm/winograd_kernels.cpp	/^void winogradOutputTransformBias(float* output, int ldout, float* WT, int outChannels, int nRowBlocks, int nColBlocks, float *biasArr, int num_threads)$/;"	f
winogradOutputTransformBiasReLU	booster/arm/winograd_kernels.cpp	/^void winogradOutputTransformBiasReLU(float* output, int ldout, float* WT, int outChannels, int nRowBlocks, int nColBlocks, float *biasArr, int num_threads)$/;"	f
winogradOutputTransformInplace	booster/arm/winograd_kernels.cpp	/^inline void winogradOutputTransformInplace(float32x2_t* o0, float32x2_t* o1, float32x4_t* w0, float32x4_t* w1, float32x4_t* w2, float32x4_t* w3)$/;"	f
winogradOutputTransformInplace	booster/arm/winograd_kernels_F63.cpp	/^inline void winogradOutputTransformInplace(float32x2_t *o0, float32x2_t *o1, float32x4_t *w0, float32x4_t *w1, float32x4_t *w2, float32x4_t *w3)$/;"	f
winogradOutputTransformReLU	booster/arm/winograd_kernels.cpp	/^void winogradOutputTransformReLU(float* output, int ldout, float* WT, int outChannels, int nRowBlocks, int nColBlocks, int num_threads)$/;"	f
winograd_f6k3_output_transform_inplace	booster/arm/winograd_kernels_F63.cpp	/^static inline void winograd_f6k3_output_transform_inplace($/;"	f	file:
winograd_f6k3_output_transform_inplace	booster/avx/winograd_kernels_F63.cpp	/^static inline void winograd_f6k3_output_transform_inplace($/;"	f	file:
winograd_f6k3_output_transform_inplace_avx	booster/avx/winograd_kernels_F63_fused.cpp	/^static inline void winograd_f6k3_output_transform_inplace_avx($/;"	f	namespace:Winograd_F63_Fused
workers	booster/include/booster/thpool.h	/^    std::vector< std::thread > workers;$/;"	m	class:ThreadPool
yuv420sp2rgb	ncnn/mat_pixel.cpp	/^void yuv420sp2rgb(const unsigned char* yuv420sp, int w, int h, unsigned char* rgb)$/;"	f	namespace:ncnn
~Allocator	ncnn/allocator.cpp	/^Allocator::~Allocator() $/;"	f	class:ncnn::Allocator
~Blob	blob.h	/^        ~Blob()$/;"	f	class:feather::Blob
~CommonMemPool	mempool.cpp	/^CommonMemPool<PTR_TYPE>::~CommonMemPool()$/;"	f	class:CommonMemPool
~ConvBooster	booster/include/booster/booster.h	/^        ~ConvBooster() {}$/;"	f	class:booster::ConvBooster
~ConvBoosterCL	booster/include/booster/booster.h	/^        ~ConvBoosterCL() {}$/;"	f	class:booster::ConvBoosterCL
~Layer	layer.cpp	/^Layer::~Layer()$/;"	f	class:feather::Layer
~Mat	ncnn/mat.h	/^inline Mat::~Mat()$/;"	f	class:ncnn::Mat
~Mutex	ncnn/allocator.h	/^    ~Mutex() { pthread_mutex_destroy(&mutex); }$/;"	f	class:ncnn::Mutex
~Mutex	ncnn/allocator.h	/^    ~Mutex() {}$/;"	f	class:ncnn::Mutex
~MutexLockGuard	ncnn/allocator.h	/^    ~MutexLockGuard() { mutex.unlock(); }$/;"	f	class:ncnn::MutexLockGuard
~Net	net.cpp	/^Net::~Net()$/;"	f	class:feather::Net
~PoolAllocator	ncnn/allocator.cpp	/^PoolAllocator::~PoolAllocator()$/;"	f	class:ncnn::PoolAllocator
~RuntimeParameter	rt_param.h	/^        ~RuntimeParameter()$/;"	f	class:RuntimeParameter
~ThreadPool	booster/include/booster/thpool.h	/^inline ThreadPool::~ThreadPool()$/;"	f	class:ThreadPool
~Timer	booster/include/booster/helper.h	/^        virtual ~Timer() {}$/;"	f	class:Timer
~UnlockedPoolAllocator	ncnn/allocator.cpp	/^UnlockedPoolAllocator::~UnlockedPoolAllocator()$/;"	f	class:ncnn::UnlockedPoolAllocator
~VkAllocator	ncnn/allocator.h	/^    virtual ~VkAllocator() { clear(); }$/;"	f	class:ncnn::VkAllocator
